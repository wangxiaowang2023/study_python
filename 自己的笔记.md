# 自己的笔记

## 面向对象

### 4.15 反射机制

- 首先： 反射机制是什么？反射机制
  首先，python是一门动态语言，python的反射机制就是指，可以在程序运行的时候获取程序的属性方法，而不需要在编码时明确知道这些对象、方法名、或属性名的具体信息，反射使得你可以在程序运行时动态地获取、操作和探索对象的属性和方法。python的反射机制核心4点：

```python
hasattr(object, "x")  # 判断对象是否有这个属性，如果有 就返回布尔值True 或 False
getattr(object, name, default=None)  # 获取一个对象的name属性，如果name属性不存在的话，返回None
setattr(object, 'x属性名', 'y属性名')  # 更新对象x属性的值，就是object.x = 'y' 如果x属性不存在，那就新增一个y属性
delattr(object, 'y属性名')  # 删除对象的一个属性y，如果属性y不存在，就会报错


```

- 1、getattr( object, name,default=None):
- 2、hasattr():
- 3、setattr():
- 4、delattr():
- 5、dir(): 这个常用，这个就时获取对象所有属性
- 6、exec():和eval():函数

作用呢？

动态调用和访问对象的属性，getattr() setattr() hasattr()这些都可以随时修改和获取对象的属性

动态获取token

```python
class ApiClient:
  def __init__(self):
    self.token = None

  def login(self, username, password):
    # 假设这里调用登录接口，获取返回的 token，并将其存储到 self.token 中
    response = self.send_request('/login', {'username': username, 'password': password})
    self.token = response['token']

  def send_request(self, endpoint, data):
    # 发送接口请求的逻辑，返回响应数据
    pass

  def request_with_token(self, endpoint, data=None):
    if self.token:
      headers = {'Authorization': f'Bearer {self.token}'}
    else:
      headers = None
    return self.send_request(endpoint, data, headers)


# 在测试中使用反射获取 token 并进行接口请求
def test_api():
  client = ApiClient()
  client.login('your_username', 'your_password')

  # 使用反射获取 token
  token = getattr(client, 'token', None)
  assert token is not None, "Token not obtained"

  # 使用 token 发送其他接口请求
  response = client.request_with_token('/some_endpoint', {'param': 'value'})
  assert response['status'] == 'success', "Request failed"

  # ... 其他测试逻辑

```

```python
# 那接口自动化的过程中，还有什么其他的方式拿token吗
# 在接口自动化过程中，除了使用反射机制外，还有一些其他的方式可以获取 token，具体取决于接口的设计和实际情况。以下是一些常见的获取 token 的方式：

# 固定 Token： 在开发环境中，可以事先创建一个特定的用户账号，为其生成一个固定的 token，用于接口测试。这样每次测试可以直接使用这个固定的 token。

# 环境变量： 将 token 存储为环境变量，测试时从环境变量中读取 token 值。这样可以在不同环境中灵活切换和管理 token。

# 动态生成： 在每次测试运行前，通过自动化脚本执行登录操作，获取实时的 token。登录成功后，从接口响应中提取 token 并存储到变量中，供后续接口请求使用。

# Token 中心： 在一些复杂的系统中，可能会有专门的 token 中心用于管理用户的身份验证信息。测试时，可以调用 token 中心的接口获取有效的 token。

# JWT（JSON Web Token）： 如果接口使用了 JWT 进行身份验证，可以根据 JWT 的生成规则生成合法的 token。这需要了解 JWT 的具体生成方式。
```

### 4.16 单例模式

- 首先，单例模式是什么？ 是软件的一种设计模式，
- 目的：无论调用多少次产生的实例对象，都是指向同一个内存地址，仅仅只有一个实力（**一个对象**）
- 方式： 首先实现单例模式的手段有很多终端鹅，但总的原则是什么，是包装你定义的一个类，只要实例化一个对象，下一次再实例化对象的时候，就直接返回你已经实例化过的这个对象，不再做实例化的操作，
  **所以这里关键的一点就是，你该如何去判断这个类是否已经实例化过一个对象**
- 这里介绍两类方式：
  - 一个是通过**模块导入**的方式；
  - 二个事通过一个**魔法方法**去判断方式
- 应用的场景呢？什么时候用单例模式去创建一个类呢？
  - 网站计数器，确保全局只有一个计数器实例化对象，用来记录网站的总访问次数。
  - **配置管理器：配置信息的管理，确保你整套代码中，只有一个配置管理器的实例，用于统一管理配置信息，比如说同意发送请求，所有的请求都是通过这个实例化对象去访问的，
    **
  - **日志记录器：全局代码运行的时候确保只有一个日志记录器的实例化对象，用来记录这套代码运行时的日志记录**
  - **数据库连接池：保证整套代码运行的过程中，只有一个数据库连接池的实例，方便管理对数据库的同意连接和同意关闭连接池**
- 注意一下：单例模式虽然可以在很多特定场景下体统便利，但不可以过度依赖单例模式导致代码的可测试性和可维护性降低

通过**模块导入**的方式怎么实现：

```python
# singleton.py
class Singleton:
  def __init__(self):
    print("Singleton instance created")


singleton_instance = Singleton()
# 在singleton.py 文件里面定义了一个类Singleton，
# 通过singleton_instance = Singleton()
```

在另一个文件中导入这个模块

```python
# main.py
import singleton

# 创建第一个实例，会输出"Singleton instance created"
instance1 = singleton.singleton_instance

# 创建第二个实例，不会再次输出"Singleton instance created"
instance2 = singleton.singleton_instance

print(instance1 is instance2)  # 输出：True，说明两个实例是同一个实例

```

通过**类绑定方法**的方式来实现单例模式

```python
# 通过在类方法中控制实例的创建和返回，可以确保在程序中只有一个实例被创建。
class Singleton:
  _instance = None

  def __init__(self):
    if Singleton._instance is not None:
      raise ValueError(
        "Singleton instance already exists")  # 第二次实例化的时候，_instance不为空 抛出异常，不打印Singleton instance created 
    Singleton._instance = self
    print("Singleton instance created")

  @classmethod
  def get_instance(cls):
    if cls._instance is None:  # 第一次实例化的时候，类的_instance为空，走到了上面的方法了，打印Singleton instance created
      cls._instance = cls()  # 
    return cls._instance


# 创建第一个实例，会输出"Singleton instance created"
instance1 = Singleton.get_instance()

# 创建第二个实例，不会再次输出"Singleton instance created"
instance2 = Singleton.get_instance()

print(instance1 is instance2)  # 输出：True，说明两个实例是同一个实例
# 原理：类的绑定方法是第二种实例化对象的方式，
# 第一次实例化的对象保存成类的数据属性 _instance，
# 第二次再实例化时，在get_singleton中判断已经有了实例对象，直接返回类的数据属性 _instance
```

# 5 魔法方法

## init 和 del

- 为什么叫魔法方法？ 只有在某种条件下才触发，像魔法一样
- init ：当你定义的类，被实例化的时候，自动执行，给对象初始化属性，这个方法里面放self.xxx属性=xxx
  然后这个xxx由init方法入参，所以你在实例化对象的时候，就需要传这个参数进去，这个参数就是对象的属性
- 这个init默认是返回None的，默认不写
- 这里要说一下del析构方法，当对象被回收的时候出发执行(程序结束、对象引用技术为0称为垃圾时)
  这里要回想下python的垃圾回收机制的一种“引用计数”，就是当引用计数为0的时候，会被定义为垃圾，会被回收

## new方法

- new方法在init方法前执行，new函数会新建一个空对象，然后这个空对象会交给init函数初始化。这个方法结束的时候，把这个空对象return出去
- 这里说说实例化对象背后发生的三件事：
  - 1、new函数先会新建一个空对象，然后返回出去；给init函数
  - 2、该空对象执行init函数，就初始化了对象的属性；
  - 3、返回初始化完成后的对象，即实例化后的对象。
- new魔法方法的一些应用场景：
  - **实现单例模式**（Singleton）:使用new方法来确保只有一个实例，并在需要时返回同一个实例。这个可以在多线程环境下确保只有一个全局实例，
  - 定制不可变类型：如果你希望创建以恶搞不可变的自定义对象，可以通过在new方法中重写对象创建的逻辑来实现（不了解）
  - 继承不可变类型：当继承python内置的不可变类型（如元组、字符串）时，你可以通过重写new方法来创建定制过程（不了解）
  - 定制元类（Metaclass）：在元类中可以重写new方法，用于控制类的创建和实例化过程。（不了解，这个可以了解一下）
  - 对象池管理：在某些情况下，你可能需要使用对象池来重用已有的对象实例，可以通过new方法来实现对象池的管理。（不了解，这个可以了解一下）

```python
# 单例模式
class Singleton:
  _instance = None

  def __new__(cls):
    if cls._instance is None:
      cls._instance = super().__new__(cls)
    return cls._instance


# 创建 Singleton 类的实例
obj1 = Singleton()  # 1622254056400
obj2 = Singleton()  # 1622254056400

print(obj1 is obj2)  # 输出：True，因为 obj1 和 obj2 引用同一个实例

```

```python
# 了解new 方法
class Student:
  def __init__(self, name, age):
    print("init:", id(self))  # new: 2176264649120
    self.name = name
    self.age = age

  def __new__(cls, *args, **kwargs):
    obj = object.__new__(cls)  # init: 2176264649120
    print("new:", id(obj))
    return obj


stu1 = Student("jack", 19)
```

