# 自己的笔记

## 面向对象

### 4.15 反射机制

- 首先： 反射机制是什么？反射机制
  首先，python是一门动态语言，python的反射机制就是指，可以在程序运行的时候获取程序的属性方法，而不需要在编码时明确知道这些对象、方法名、或属性名的具体信息，反射使得你可以在程序运行时动态地获取、操作和探索对象的属性和方法。python的反射机制核心4点：

```python
hasattr(object, "x")  # 判断对象是否有这个属性，如果有 就返回布尔值True 或 False
getattr(object, name, default=None)  # 获取一个对象的name属性，如果name属性不存在的话，返回None
setattr(object, 'x属性名', 'y属性名')  # 更新对象x属性的值，就是object.x = 'y' 如果x属性不存在，那就新增一个y属性
delattr(object, 'y属性名')  # 删除对象的一个属性y，如果属性y不存在，就会报错


```

- 1、getattr( object, name,default=None):
- 2、hasattr():
- 3、setattr():
- 4、delattr():
- 5、dir(): 这个常用，这个就时获取对象所有属性
- 6、exec():和eval():函数

作用呢？

动态调用和访问对象的属性，getattr() setattr() hasattr()这些都可以随时修改和获取对象的属性

动态获取token

```python
class ApiClient:
  def __init__(self):
    self.token = None

  def login(self, username, password):
    # 假设这里调用登录接口，获取返回的 token，并将其存储到 self.token 中
    response = self.send_request('/login', {'username': username, 'password': password})
    self.token = response['token']

  def send_request(self, endpoint, data):
    # 发送接口请求的逻辑，返回响应数据
    pass

  def request_with_token(self, endpoint, data=None):
    if self.token:
      headers = {'Authorization': f'Bearer {self.token}'}
    else:
      headers = None
    return self.send_request(endpoint, data, headers)


# 在测试中使用反射获取 token 并进行接口请求
def test_api():
  client = ApiClient()
  client.login('your_username', 'your_password')

  # 使用反射获取 token
  token = getattr(client, 'token', None)
  assert token is not None, "Token not obtained"

  # 使用 token 发送其他接口请求
  response = client.request_with_token('/some_endpoint', {'param': 'value'})
  assert response['status'] == 'success', "Request failed"

  # ... 其他测试逻辑

```

```python
# 那接口自动化的过程中，还有什么其他的方式拿token吗
# 在接口自动化过程中，除了使用反射机制外，还有一些其他的方式可以获取 token，具体取决于接口的设计和实际情况。以下是一些常见的获取 token 的方式：

# 固定 Token： 在开发环境中，可以事先创建一个特定的用户账号，为其生成一个固定的 token，用于接口测试。这样每次测试可以直接使用这个固定的 token。

# 环境变量： 将 token 存储为环境变量，测试时从环境变量中读取 token 值。这样可以在不同环境中灵活切换和管理 token。

# 动态生成： 在每次测试运行前，通过自动化脚本执行登录操作，获取实时的 token。登录成功后，从接口响应中提取 token 并存储到变量中，供后续接口请求使用。

# Token 中心： 在一些复杂的系统中，可能会有专门的 token 中心用于管理用户的身份验证信息。测试时，可以调用 token 中心的接口获取有效的 token。

# JWT（JSON Web Token）： 如果接口使用了 JWT 进行身份验证，可以根据 JWT 的生成规则生成合法的 token。这需要了解 JWT 的具体生成方式。
```

### 4.16 单例模式

- 首先，单例模式是什么？ 是软件的一种设计模式，
- 目的：无论调用多少次产生的实例对象，都是指向同一个内存地址，仅仅只有一个实力（**一个对象**）
- 方式： 首先实现单例模式的手段有很多终端鹅，但总的原则是什么，是包装你定义的一个类，只要实例化一个对象，下一次再实例化对象的时候，就直接返回你已经实例化过的这个对象，不再做实例化的操作，
  **所以这里关键的一点就是，你该如何去判断这个类是否已经实例化过一个对象**
- 这里介绍两类方式：
  - 一个是通过**模块导入**的方式；
  - 二个事通过一个**魔法方法**去判断方式
- 应用的场景呢？什么时候用单例模式去创建一个类呢？
  - 网站计数器，确保全局只有一个计数器实例化对象，用来记录网站的总访问次数。
  - **配置管理器：配置信息的管理，确保你整套代码中，只有一个配置管理器的实例，用于统一管理配置信息，比如说同意发送请求，所有的请求都是通过这个实例化对象去访问的，
    **
  - **日志记录器：全局代码运行的时候确保只有一个日志记录器的实例化对象，用来记录这套代码运行时的日志记录**
  - **数据库连接池：保证整套代码运行的过程中，只有一个数据库连接池的实例，方便管理对数据库的同意连接和同意关闭连接池**
- 注意一下：单例模式虽然可以在很多特定场景下体统便利，但不可以过度依赖单例模式导致代码的可测试性和可维护性降低

通过**模块导入**的方式怎么实现：

```python
# singleton.py
class Singleton:
  def __init__(self):
    print("Singleton instance created")


singleton_instance = Singleton()
# 在singleton.py 文件里面定义了一个类Singleton，
# 通过singleton_instance = Singleton()
```

在另一个文件中导入这个模块

```python
# main.py
import singleton

# 创建第一个实例，会输出"Singleton instance created"
instance1 = singleton.singleton_instance

# 创建第二个实例，不会再次输出"Singleton instance created"
instance2 = singleton.singleton_instance

print(instance1 is instance2)  # 输出：True，说明两个实例是同一个实例

```

通过**类绑定方法**的方式来实现单例模式

```python
# 通过在类方法中控制实例的创建和返回，可以确保在程序中只有一个实例被创建。
class Singleton:
  _instance = None

  def __init__(self):
    if Singleton._instance is not None:
      raise ValueError(
        "Singleton instance already exists")  # 第二次实例化的时候，_instance不为空 抛出异常，不打印Singleton instance created 
    Singleton._instance = self
    print("Singleton instance created")

  @classmethod
  def get_instance(cls):
    if cls._instance is None:  # 第一次实例化的时候，类的_instance为空，走到了上面的方法了，打印Singleton instance created
      cls._instance = cls()  # 
    return cls._instance


# 创建第一个实例，会输出"Singleton instance created"
instance1 = Singleton.get_instance()

# 创建第二个实例，不会再次输出"Singleton instance created"
instance2 = Singleton.get_instance()

print(instance1 is instance2)  # 输出：True，说明两个实例是同一个实例
# 原理：类的绑定方法是第二种实例化对象的方式，
# 第一次实例化的对象保存成类的数据属性 _instance，
# 第二次再实例化时，在get_singleton中判断已经有了实例对象，直接返回类的数据属性 _instance
```

# 5 魔法方法

## init 和 del

- 为什么叫魔法方法？ 只有在某种条件下才触发，像魔法一样
- init ：当你定义的类，被实例化的时候，自动执行，给对象初始化属性，这个方法里面放self.xxx属性=xxx
  然后这个xxx由init方法入参，所以你在实例化对象的时候，就需要传这个参数进去，这个参数就是对象的属性
- 这个init默认是返回None的，默认不写
- 这里要说一下del析构方法，当对象被回收的时候出发执行(程序结束、对象引用技术为0称为垃圾时)
  这里要回想下python的垃圾回收机制的一种“引用计数”，就是当引用计数为0的时候，会被定义为垃圾，会被回收

## new方法

- new方法在init方法前执行，new函数会新建一个空对象，然后这个空对象会交给init函数初始化。这个方法结束的时候，把这个空对象return出去
- 这里说说实例化对象背后发生的三件事：
  - 1、new函数先会新建一个空对象，然后返回出去；给init函数
  - 2、该空对象执行init函数，就初始化了对象的属性；
  - 3、返回初始化完成后的对象，即实例化后的对象。
- new魔法方法的一些应用场景：
  - **实现单例模式**（Singleton）:使用new方法来确保只有一个实例，并在需要时返回同一个实例。这个可以在多线程环境下确保只有一个全局实例，
  - 定制不可变类型：如果你希望创建以恶搞不可变的自定义对象，可以通过在new方法中重写对象创建的逻辑来实现（不了解）
  - 继承不可变类型：当继承python内置的不可变类型（如元组、字符串）时，你可以通过重写new方法来创建定制过程（不了解）
  - 定制元类（Metaclass）：在元类中可以重写new方法，用于控制类的创建和实例化过程。（不了解，这个可以了解一下）
  - 对象池管理：在某些情况下，你可能需要使用对象池来重用已有的对象实例，可以通过new方法来实现对象池的管理。（不了解，这个可以了解一下）

```python
# 单例模式
class Singleton:
  _instance = None

  def __new__(cls):
    if cls._instance is None:
      cls._instance = super().__new__(cls)
    return cls._instance


# 创建 Singleton 类的实例
obj1 = Singleton()  # 1622254056400
obj2 = Singleton()  # 1622254056400

print(obj1 is obj2)  # 输出：True，因为 obj1 和 obj2 引用同一个实例

```

```python
# 了解new 方法
class Student:
  def __init__(self, name, age):
    print("init:", id(self))  # new: 2176264649120
    self.name = name
    self.age = age

  def __new__(cls, *args, **kwargs):
    obj = object.__new__(cls)  # init: 2176264649120
    print("new:", id(obj))
    return obj


stu1 = Student("jack", 19)
```

## 5.3 call

- 类中的call在对象被调用时出发。就是当对象加括号被调用时触发
- 对象或者变量，只有实现了call方法，才是可调用对象，才可以被执行，否则就会报错， object is not callable
- 定义了call后，你实例化的对象可以像函数一样被调用，

```python
class CallableClass:
    def __init__(self, value):
        self.value = value
    
    def __call__(self, x):
        return self.value * x

# 创建一个可调用的对象
callable_obj = CallableClass(5)

# 调用对象，就像调用函数一样
result = callable_obj(10)
print(result)  # 输出：50

```

总结就是，可以把类当方法直接调用

场景呢？

- 当你希望某个对象能像函数一样调用且获得返回值时
- __call__方法并结合with语句和`__enter__`和`__exit__`方法。实现上下文管理
- call实现装饰器

```python
class MyDecorator:
    def __init__(self, func):
        self.func = func # 函数作为入参，传进来作为属性

    def __call__(self, *args, **kwargs):
        print("Before function is called") # 调用属性
        result = self.func(*args, **kwargs) # 这是被装饰的方法
        print("After function is called")
        return result

@MyDecorator
def my_function(x, y):
    return x + y

result = my_function(3, 5)
print("Result:", result)
Before function is called
After function is called
Result: 8

```

- **装饰器实现，两种方式**
  - **第一个是常规的，闭包，嵌套函数**
  - **第二个就是定义带call的类。讲函数作为init入参传进来**

## 5.4 str和repr

- str：当对象被访问打印时触发执行，他必须有一个字符串类型的返回值

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return f"Person(name={self.name}, age={self.age})"

person = Person("Alice", 30)
print(person)  # Output: Person(name=Alice, age=30)

sut = Student("name","age")
print(sut) # 这个时候打印出来的内容，就是str方法return出来的内容
```

好这个我知道了，那应用的场景呢？

- 总之，`__str__` 魔法方法适用于需要自定义对象的可读性、用户友好性和调试信息的情况。它使你能够以更有意义的方式呈现对象，并提供有关对象状态和属性的重要信息。

- repr，本质和srt一样，都是对象被打印时显示的内容，但是
- **与`__str__`的区别：** `__str__` 应该返回更友好、易读的字符串，而 `__repr__` 则应该返回更详细、可复制的字符串，通常包含足够的信息来重新创建对象。

## 5.5 比较系列

两个对象是可以比较的，但是比较的结果可能不是我们预期的，此时可以重写比较系列的魔法方法，实现自定义比较逻辑

- eq
  - `__eq__` 方法是 Python 中的一个魔法方法，用于定义对象的相等性比较操作。当你在自定义类中实现了 `__eq__`
    方法时，你可以自定义对象之间的相等性判断规则

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __eq__(self, other):
        if isinstance(other, Person):
            print("eq被执行了")  # 只有当你在判断两个对象是否相等时，这个方法才会被触发
            return self.name == other.name and self.age == other.age
        return False


person1 = Person("Alice", 25)
person2 = Person("Bob", 30)
person3 = Person("Alice", 25)
# print(person1.name)
print(person1 == person2)  # False，根据 __eq__ 方法的定义，person1 和 person2 不相等
print(person1 == person3)  # True，根据 __eq__ 方法的定义，person1 和 person3 相等
# eq被执行了
# False
# eq被执行了
# True
```

- 同样的道理，其他比较系列的放啊
- nq，实现的是是够不相等的逻辑。如果没有实现，则默认是eq的结果取反。
- 该系列其他魔法方法：`__lt__、__gt__、__le__、__ge__`分别表示小于、大于、小于等于和大于等于。

## 5.6 attr系列 阿特

- 这个系列就和之前学习反射的时候是一样的道理

```python
class Person:

    def __init__(self, name):
        self.name = name

    def __getattr__(self, item):
        print('调用不存在的属性会触发我')
        return self.__dict__.get(item) # 
        # return self.item      # 不能使用，会造成递归。

    def __setattr__(self, key, value): 
        print('设置修改对象属性时触发我') # 这个在实例化对象的时候会被触发，可以有其他用处
        self.__dict__[key] = value

    def __delattr__(self, item):
        print('删除对象属性时触发我')
        self.__dict__.pop(item)


p = Person('jack')      # 触发__setattr__
p.name = 'mack'         # 触发__setattr__
print(p.age)            # 触发__getattr__
p.age = 18              # 触发__setattr__
print(p.age)            
del p.age               # __delattr__
```

- 示例二，让字典，实现像对象一样的点操作

```python
class MyDict(dict):
    abc = "abc"

    def __getattr__(self, item):
        print("字典对象通过点访问不存在的属性时触发")
        return self.get(item)

    def __setattr__(self, key, value):
        if not isinstance(value, str):
            raise ValueError('值必须是字符串类型')
        self[key] = value


d = MyDict({'name': 'jack'})
print(d.name)               # 触发 __getattr__
print(d.abc)                # 没有触发 __getattr__
```

## 5.7 item系列 伊藤姆，和attr一样用

实现普通对象像字典一样通过 [ ] 操作 和attr一样理解

item:项目

attr: attribute： 属性的英文

```python
class Person(object):

    def __init__(self, name):
        self.name = name

    def __setitem__(self, key, value):
        print("[]设置值时触发")
        setattr(self, key, value)

    def __getitem__(self, item):
        print("[]取值时触发")
        return getattr(self, item)

    def __delitem__(self, key):
        print("del p[key]时触发", key)


p = Person('jack')
p['name'] = 'mack'			 # 需要__setitem__才可以
print(p['name'])           	  # 需要__getitem__才可以
print(p.__dict__)

del p["name"]				# 需要__delitem__才可以
```

## 5.8 enter恩特和exit艾涩特

- 上下文管理器：
  - 执行代码块前后的操作，
  - 文件也是代码块
- with ：顺着
  - 顺着上下文管理器
- with open(file , mode操作模式)  mode就是r读取和w写入的模式选择
  - 这里的with open中的open( )函数所返回出来的对象就是一个上下文管理器，这个对象实现了enter方法和exit方法 用于对文件的自动打开和关闭，
  - 如果没有open，那我们的代码应该是怎么写的？
    - 就像数据库一样
    - file = open ( 'file' , mode )
    - file.write("hello,world")
    - file.close( )
    - 但是这样写不好看很麻烦，with open 就自动帮我们实现了打开和写入和关闭的操作
- 好，说到这里，就能理解enter和exit了
- 这个代码里的MyOpen就是我们的自己定义的上下文管理器，这个类所返回出来的对象就是一个上下文管理器，实现了enter和exit方法打开和关闭

```python
class MyOpen:
    def __init__(self, file_name: str, mode="r"):
        self.file = open(file_name, mode)

    def __enter__(self):
        print("进入with语句块时触发")
        return self.file        # 返回值赋值给 as后面的接收值

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("退出with语句块时触发，不论with语句块内是够有异常报错，__exit__都会被执行")
        self.file.close()


        
with MyOpen("text.txt", "w") as f:
    f.write("hello world")
```

## 5.9 iter和next

见名知意，这两个方法是实现迭代器功能的，比如实现一个range

这样我们就知道了range原理

```python
# 普通range
for i in range(10):
    print(i)
```

- 通过自己定义这两个魔法方法实现自己的range

```python
import time

class MyRange():
    def __init__(self,total: int,step: int=1):
        self.count = 0  # 这里都是定义属性
        self.total = total
        self.step = step 
    def __iter__(self):  # 
        print("1111")
        return self  # for循环第一个进入时执行一次，需要返回一个实现了__next__的迭代器对象
    def __next__(self):
        time.sleep(0.5)
        self.count += self.step # 没次运行加1或者自定义的数
        if self.count == self.total:
            reise StopIteration # 如果count计数等于total总数时引发迭代异常，不是抛出，这个迭代异常表示迭代结束
        return self.count 
    
for i in MyRange(10,2):
    print(i)
```

- 总结一下，
- iter 当一个类，定义了iter魔法方法，这个类的实例，就被认为是可迭代的（iterable)
  - iter方法应返回一个迭代器对象，可以是self，也可以是另一个实现了next方法的对象
- next 方法：这个方法用于获取迭代中的下一个值。
  - 如果没有更多的值可迭代，应该要引发StopIteration异常，表示迭代结束

## 5.10其他魔法方法

### getattribute系列 attribute艾tiubiute就是属性的意思

- 调用对象不存在的属性的时候，会访问getattr
- 访问对象的属性不管存在不存在都会触发getattribute方法
- 除非getattribute抛出AttributeError异常才会触发getattr
- 所以当你访问对象的属性不管存在不存在都会触发getattribute异常

```python
class Foo:
    def __init__(self,x):
        self.x = x

    def __getattr__(self, item):
        print('执行的是我')

    def __getattribute__(self, item):
        print('不管是否存在,我都会执行')
        raise AttributeError('哈哈')


f1=Foo(10)

f1.x
f1.y
```

### module、class、name

- **module**：模块，表示当前错爱早的对象在哪个模块
- class：类 表示当前操作对象的类是什么
- name： 表示当前对象的名字是什么
-

### slot、all

- slot：控制对象在实例化后可以持支持哪些属性
- 是一个用于限制对象属性的特殊属性，它是一种用于优化内存占用和属性访问速度的机制。通过在类中定义 `__slots__`
  属性，你可以指定一个属性名称的列表，从而限制类的实例只能具有指定列表中的属性。
- all：
- 在模块文件中设置 `__all__` 变量，当其它文件以“from 模块名 import *”的形式导入该模块时，该文件中只能使用 `__all__`
  列表中指定的成员。

```python
# tools.py

def add(a: int, b: int):
    return a + b

def mul(a: int, b: int):
    return a * b


def xsum(nums: list):
    return sum(nums)


__all__ = ["add", "mul"]
```

