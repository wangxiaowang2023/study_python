# 自己的笔记

## 面向对象

### 4.15 反射机制

- 首先： 反射机制是什么？反射机制
  首先，python是一门动态语言，python的反射机制就是指，可以在程序运行的时候获取程序的属性方法，而不需要在编码时明确知道这些对象、方法名、或属性名的具体信息，反射使得你可以在程序运行时动态地获取、操作和探索对象的属性和方法。python的反射机制核心4点：

```python
hasattr(object, "x")  # 判断对象是否有这个属性，如果有 就返回布尔值True 或 False
getattr(object, name, default=None)  # 获取一个对象的name属性，如果name属性不存在的话，返回None
setattr(object, 'x属性名', 'y属性名')  # 更新对象x属性的值，就是object.x = 'y' 如果x属性不存在，那就新增一个y属性
delattr(object, 'y属性名')  # 删除对象的一个属性y，如果属性y不存在，就会报错


```

- 1、getattr( object, name,default=None):
- 2、hasattr():
- 3、setattr():
- 4、delattr():
- 5、dir(): 这个常用，这个就时获取对象所有属性
- 6、exec():和eval():函数

作用呢？

动态调用和访问对象的属性，getattr() setattr() hasattr()这些都可以随时修改和获取对象的属性

动态获取token

```python
class ApiClient:
  def __init__(self):
    self.token = None

  def login(self, username, password):
    # 假设这里调用登录接口，获取返回的 token，并将其存储到 self.token 中
    response = self.send_request('/login', {'username': username, 'password': password})
    self.token = response['token']

  def send_request(self, endpoint, data):
    # 发送接口请求的逻辑，返回响应数据
    pass

  def request_with_token(self, endpoint, data=None):
    if self.token:
      headers = {'Authorization': f'Bearer {self.token}'}
    else:
      headers = None
    return self.send_request(endpoint, data, headers)


# 在测试中使用反射获取 token 并进行接口请求
def test_api():
  client = ApiClient()
  client.login('your_username', 'your_password')

  # 使用反射获取 token
  token = getattr(client, 'token', None)
  assert token is not None, "Token not obtained"

  # 使用 token 发送其他接口请求
  response = client.request_with_token('/some_endpoint', {'param': 'value'})
  assert response['status'] == 'success', "Request failed"

  # ... 其他测试逻辑

```

```python
# 那接口自动化的过程中，还有什么其他的方式拿token吗
# 在接口自动化过程中，除了使用反射机制外，还有一些其他的方式可以获取 token，具体取决于接口的设计和实际情况。以下是一些常见的获取 token 的方式：

# 固定 Token： 在开发环境中，可以事先创建一个特定的用户账号，为其生成一个固定的 token，用于接口测试。这样每次测试可以直接使用这个固定的 token。

# 环境变量： 将 token 存储为环境变量，测试时从环境变量中读取 token 值。这样可以在不同环境中灵活切换和管理 token。

# 动态生成： 在每次测试运行前，通过自动化脚本执行登录操作，获取实时的 token。登录成功后，从接口响应中提取 token 并存储到变量中，供后续接口请求使用。

# Token 中心： 在一些复杂的系统中，可能会有专门的 token 中心用于管理用户的身份验证信息。测试时，可以调用 token 中心的接口获取有效的 token。

# JWT（JSON Web Token）： 如果接口使用了 JWT 进行身份验证，可以根据 JWT 的生成规则生成合法的 token。这需要了解 JWT 的具体生成方式。
```

### 4.16 单例模式

- 首先，单例模式是什么？ 是软件的一种设计模式，
- 目的：无论调用多少次产生的实例对象，都是指向同一个内存地址，仅仅只有一个实力（**一个对象**）
- 方式： 首先实现单例模式的手段有很多终端鹅，但总的原则是什么，是包装你定义的一个类，只要实例化一个对象，下一次再实例化对象的时候，就直接返回你已经实例化过的这个对象，不再做实例化的操作，
  **所以这里关键的一点就是，你该如何去判断这个类是否已经实例化过一个对象**
- 这里介绍两类方式：
  - 一个是通过**模块导入**的方式；
  - 二个事通过一个**魔法方法**去判断方式
- 应用的场景呢？什么时候用单例模式去创建一个类呢？
  - 网站计数器，确保全局只有一个计数器实例化对象，用来记录网站的总访问次数。
  - **配置管理器：配置信息的管理，确保你整套代码中，只有一个配置管理器的实例，用于统一管理配置信息，比如说同意发送请求，所有的请求都是通过这个实例化对象去访问的，
    **
  - **日志记录器：全局代码运行的时候确保只有一个日志记录器的实例化对象，用来记录这套代码运行时的日志记录**
  - **数据库连接池：保证整套代码运行的过程中，只有一个数据库连接池的实例，方便管理对数据库的同意连接和同意关闭连接池**
- 注意一下：单例模式虽然可以在很多特定场景下体统便利，但不可以过度依赖单例模式导致代码的可测试性和可维护性降低

通过**模块导入**的方式怎么实现：

```python
# singleton.py
class Singleton:
  def __init__(self):
    print("Singleton instance created")


singleton_instance = Singleton()
# 在singleton.py 文件里面定义了一个类Singleton，
# 通过singleton_instance = Singleton()
```

在另一个文件中导入这个模块

```python
# main.py
import singleton

# 创建第一个实例，会输出"Singleton instance created"
instance1 = singleton.singleton_instance

# 创建第二个实例，不会再次输出"Singleton instance created"
instance2 = singleton.singleton_instance

print(instance1 is instance2)  # 输出：True，说明两个实例是同一个实例

```

通过**类绑定方法**的方式来实现单例模式

```python
# 通过在类方法中控制实例的创建和返回，可以确保在程序中只有一个实例被创建。
class Singleton:
  _instance = None

  def __init__(self):
    if Singleton._instance is not None:
      raise ValueError(
        "Singleton instance already exists")  # 第二次实例化的时候，_instance不为空 抛出异常，不打印Singleton instance created 
    Singleton._instance = self
    print("Singleton instance created")

  @classmethod
  def get_instance(cls):
    if cls._instance is None:  # 第一次实例化的时候，类的_instance为空，走到了上面的方法了，打印Singleton instance created
      cls._instance = cls()  # 
    return cls._instance


# 创建第一个实例，会输出"Singleton instance created"
instance1 = Singleton.get_instance()

# 创建第二个实例，不会再次输出"Singleton instance created"
instance2 = Singleton.get_instance()

print(instance1 is instance2)  # 输出：True，说明两个实例是同一个实例
# 原理：类的绑定方法是第二种实例化对象的方式，
# 第一次实例化的对象保存成类的数据属性 _instance，
# 第二次再实例化时，在get_singleton中判断已经有了实例对象，直接返回类的数据属性 _instance
```

# 5 魔法方法

## init 和 del

- 为什么叫魔法方法？ 只有在某种条件下才触发，像魔法一样
- init ：当你定义的类，被实例化的时候，自动执行，给对象初始化属性，这个方法里面放self.xxx属性=xxx
  然后这个xxx由init方法入参，所以你在实例化对象的时候，就需要传这个参数进去，这个参数就是对象的属性
- 这个init默认是返回None的，默认不写
- 这里要说一下del析构方法，当对象被回收的时候出发执行(程序结束、对象引用技术为0称为垃圾时)
  这里要回想下python的垃圾回收机制的一种“引用计数”，就是当引用计数为0的时候，会被定义为垃圾，会被回收

## new方法

- new方法在init方法前执行，new函数会新建一个空对象，然后这个空对象会交给init函数初始化。这个方法结束的时候，把这个空对象return出去
- 这里说说实例化对象背后发生的三件事：
  - 1、new函数先会新建一个空对象，然后返回出去；给init函数
  - 2、该空对象执行init函数，就初始化了对象的属性；
  - 3、返回初始化完成后的对象，即实例化后的对象。
- new魔法方法的一些应用场景：
  - **实现单例模式**（Singleton）:使用new方法来确保只有一个实例，并在需要时返回同一个实例。这个可以在多线程环境下确保只有一个全局实例，
  - 定制不可变类型：如果你希望创建以恶搞不可变的自定义对象，可以通过在new方法中重写对象创建的逻辑来实现（不了解）
  - 继承不可变类型：当继承python内置的不可变类型（如元组、字符串）时，你可以通过重写new方法来创建定制过程（不了解）
  - 定制元类（Metaclass）：在元类中可以重写new方法，用于控制类的创建和实例化过程。（不了解，这个可以了解一下）
  - 对象池管理：在某些情况下，你可能需要使用对象池来重用已有的对象实例，可以通过new方法来实现对象池的管理。（不了解，这个可以了解一下）

```python
# 单例模式
class Singleton:
  _instance = None

  def __new__(cls):
    if cls._instance is None:
      cls._instance = super().__new__(cls)
    return cls._instance


# 创建 Singleton 类的实例
obj1 = Singleton()  # 1622254056400
obj2 = Singleton()  # 1622254056400

print(obj1 is obj2)  # 输出：True，因为 obj1 和 obj2 引用同一个实例

```

```python
# 了解new 方法
class Student:
  def __init__(self, name, age):
    print("init:", id(self))  # new: 2176264649120
    self.name = name
    self.age = age

  def __new__(cls, *args, **kwargs):
    obj = object.__new__(cls)  # init: 2176264649120
    print("new:", id(obj))
    return obj


stu1 = Student("jack", 19)
```







# 元类

## 6.1 类也是对象

- 元类是什么？要先了解类是什么？
- Python是一切皆对象，哪怕你定义一个变量，它也是对象，那类是什么？ 类可以想象成是对象的模版，是类定义了对象，对象是类实例化的产物，
- 那类是对象的模板，什么是类的类（模版）呢？
- 元类就是类的类（模版）默认元类type
- 你可以自定义这个元类来实现有区别于类的类

## 6.2 class机制

class是python的一个关键字，目的是用来创建类，那这个关键字的背后是什么逻辑呢？

- 第一步：**获取类名** class_name = Student
- 第二步： **获取基类们：** class_bases=(object,)
- 第三步：**获取类的名称空间：** class_dict = {"--init--" ：--init--,"--talk--":talk}
- 第四步：**调用元类type实例化产生Student类这个对象**

```python
def __init__(self, name, age):
    self.name = name
    self.age = age


def talk(self):
    print('hello')


class_name = "Student"
class_bases = (object, )
class_dict = {"__init__": __init__, "talk": talk}  #  字典


Student = type(class_name, class_bases, class_dict)  # 自定义了元类信息，Student是实例化对象

stu = Student("jack", 18)
print(stu.talk())
```

- 但是如果按照这四步走就比较繁琐，所以正常是用python的关键字class 来定义类的

## 6.3 自定义元类

上面我们知道了class的原理，那我们自定义元类，就是在做第四步的自定义，即使用不同的元类实例化这个对象，目的是为了按照需求控制类的定义和调用

metaclass=type就是让他指向type元类，这是所有类的基石

```python
class Student(metaclass=type):	# class机制默认的元类是type：我们可以修改metaclass参数来选择自定义元类
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def talk(self):
        print('hello')
```

- type是一切类的即是，所以我们自定义的元类，也必须继承自type
- 自定义的元类继承type的目的是使用type的大部分功能，我们只定制（重写方法）我们需要的那一部分功能

```python
class Mymeta(type):		# 只有继承了type的类才能作为元类使用
    # 在这个里面去重写type的方法去自定义自己的元类
    pass


class Student(metaclass=Mymeta):	# 使用Mytema元类，即Mymeta(class_name, class_bases, class_dict)
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
    def talk(self):
        print('hello')
```

## 6.4 自定义元类控制类的定义

自定义元类定制类的时候，需要再自定义的元类中实现init()方法

```python
class Mymeta(type):
    def __init__(self, class_name, class_bases, class_dict):

        if not class_name.istitle():			# 自定制需求 istitle()用于检查字符串的首字母是否大写，如果大写就是Ture，否则Flase
            raise NameError('类名首字母必须大写')
 
        if not self.__doc__:  # # 如果类的__doc__属性是空，就抛出异常 doc就是注释那里
            raise TypeError('类必须要有文档注释')

        super().__init__(class_name, class_bases, class_dict)


# People = Mymeta(class_name, class_bases, class_dict),
class People(object, metaclass=Mymeta):
    """
    deox
    """
    x = 10
    def f(self):
        pass



print(People.__dict__)
```

## 6.5实例化对象的本质是什么？

回顾一下，实例化一个对象时会发生什么？ 

- **第一件事：创建了一个空对象，--new--方法**
- **第二件事：初始化了这个空对象  --init--**
- **最后：返回初始化完成的对象**
  - new（）创建空对象，且返回这个空对象
  - init() 接收了这个空对象，并完成了初始化该对象
  - 最后，返回初始化完成的对象。

整个三步流程，是由类的类，即元类中的--call--()方法管理的（定义.类() ），因为实例化对象，类加括号，即类的调用。类被当一个对象看待时，直接以类方法调用，就会触发它的--call--()函数的执行，即实例化对象时，出发了元类的--call--()函数

在元类--call--()内实现实例化的三件事。

当我们默认使用的是type元类时，想要**定制实例化的这个过程中**的需求是无法实现的，因为我们无法修改内置元类type的--call--方法。

当我们使用自定义元类的时候，就可以实现**实例化过程需求的自定义**，因为我们可以重写自定义元类的--call--方法，从而实现自定义实例化需求

## 6.6 自定义元类控制类的调用

类的调用： 就是类加括号，也就是实例化对象

**你实例化一个类的对象时，实际上会调用类的 `__call__` 方法（如果定义了的话）。这种行为使得类的实例可以像函数一样被调用。**

控制类的调用就是控制对象的额实例化过程。类的调用就会触发元类的--call--方法执行

```python
class Mymeta(type):
    def __call__(cls, *args, **kwargs):
        # 第一步: 调用Student下面的__new__创建一个空对象, 无则使用类(type)的__new__
        obj = cls.__new__(cls, *args, **kwargs)
        # 第二步：调用Student下面的__init__初始化对象
        cls.__init__(obj, *args, **kwargs)        # 等价于： obj.__init__(*args, **kwargs)
        # 第三步：返回对象
        return obj


class Student(object, metaclass=Mymeta):
    def __init__(self, name, age):
        self.name = name
        self.age = age


jack = Student('jack', 18)   # People.__call__('jack', 18)
```

## 6.7 通过new实现单例模式

回顾一下单例模式：

- 一个类只实例化一个对象的一种编程思维，就是单例模式
- 怎么实现： 通过自定义--new--()魔法方法实现，判断类的实例化对象是否已经有了，有了就直接返回这个实例化对象，没有就可以new一个实例化并保存返回。看看对象

```python
class Student():
    _instance = None # 默认类的属性_instance是空
    def __new__(cls,*args, **kwargs):
        self.name = name
        self.age = age
        
    def __new__(cls,*args, **kwargs):  
        if cls._instance:  # 判断，如果cls._instance is Ture就是指判断他是否有实例
            return cls._instance # 如果有就直接返回这个实例
        else:
            cls._instance = super().__new__(cls)    # 如果没有，就新建一个实例化对象
            return cls._instance   # 并且返回
        
    def __new__(cls, *agrs, **kwagrs):
        if not cls._instance:
            cls._instances = super().__new__(cls)  # 如果没有，就新建一个
        return cls.instances  # 不管有没有实例化对象，都返回这个对象， 如果有就直接返回

```

## 6.8 通过元类来实现单例模式【重点】

思路是什么？

- 首先，这个实现的点在哪里？在类的定义阶段就确保类的实例化行为符合单例模式，
- 呐你单例模式，是在定义类的时候做判断，通过类的--new--()方法里面去做判断，如果这个类有实例化对象，就返回这个对象，如果没有就新建一个对象返回，
  - 这里插一句，实例化的过程发生了什么？1、--new--新建一个空对象且返回出去给--init-- 2、--init--接收这个空对象，进行初始化，就是slef.name=name，3、将这个初始化过的对象返回去。就是调用类的‘爸爸’’元类的--call--方法，--call--就是.类()把类当方法用的方法
- 好的，现在我们知道了实例化过程，那我们除了可以在new方法这里做判断，还可以在定义类的‘‘爸爸’’元类的时候去做判断
- 因为你在实例化的时候，就是调用了类的‘‘爸爸’’元类的--call--方法去实例化的（--call--把类当方法用）
- 好，现在我们知道了要去自定义元类的--call--方法，也就是在调用--call--的时候去做判断，判断这个类有没有实例化对象，如果有就直接返回这个对象，如果没有就新建一个对象然后再返回这个对象。
- 好我现在要再自定义的原来上面去做判断是吧，那怎么自定义元类？且看代码

```python
class Mymeta(type):
    def __init__(cls, name,bases,dic):
        super().__init__(name,bases,dic)
        cls._instance = None   # 将记录类的实例化对象的数据属性放在元类中自动定义了 这里和之前定义类的时候是一个意思
    def __call__(cls,*args, **kwargs):  # 此call会在类被调用（即实例化时出发）
        if cls._instance:  # 判断类有没有实例化对象
            return cls._instance # 如果有就返回这个实例化对象啊
        else:  # 如果没有
            obj = cls.__new__(cls, *args, **kwargs) # 那就控制类造一个空对象并完成初始化
            obj.__init__(*args,**kwargs) #  那就控制类造一个空对象并完成初始化
            cls._instance = obj # 保存这个对象，那cls的_instance是这个对象，下一次再实例化的时候就直接返回而不用再造对象
            return obj # 返回这个对象
        
        
class Student(metaclass=Mymeta):
    def __init__(self,name,age):
        self.name=name
        self.age=age
        
        
stu1 = Student("jone",18)
stu2 = Student('xiaoming',19)
print(stu1 is stu2)
print(stu1.__dict__,stu2.__dict__)
```

原理解读：类定义时会调用元类下面的--init--(),类调用（实例化对象）时会触发元类下的--call--方法

类在定义时，给类新增一个空的数据属性，

第一次实例化的时候，实例化之后就会将这个对象赋值给类的数据属性； # 所以第一次实例化的时候，就获得了这个属性

第二次再实例化的时候，直接返回类的这个数据属性

和自定类的时候单例不同的是，类的这个数据属性是放在元类中自动定义的，而不是在类中显示的定义的

类调用时，出发元类--call--方法判断是否有实例化对象，而不是在类的额绑定方法中做判断。

