# 自己的笔记

## 面向对象
# 

# 1 基础回顾

## 1.1变量赋值和引用

- 当有一个新变量的时候，内存空间就会开辟一块数据存储
- 变量不同，地址是不同的，可以用id( )获取内存地址

变量引用的本质就是将这个变量的内存地址，关联到一个新变量中，两个变量指向的是同一个地址，

所以变量是不占内存的，

## 1.2 小整数池

小整数池呢就是Python解释器在程序开始运行的时候就预先开辟的一块内存空间，存放一部分的整数，方便后面去调用，用于优化资源消耗的

## 1.3 垃圾回收机制

变量使用前需要先定义，定义就是开辟了空间，如果需要用到很多数据那么就会开辟很多空间，空间是有限的，开多了会造成浪费和溢出的风险，所以需要在使用后就释放这个空间，

python解释器自动的帮我们做了这个清理内存空间的机制，

采用的是引用计数的方式回收垃圾。

什么是垃圾？垃圾就是没有绑定变量名的值，也就是无法访问的值，就是没有用的值

如何回收垃圾？：通过引用计数的方式，就是当这个值被引用的时候，就会绑定到一个新的变量名伤，引用计数就会加1 

```python
# 如：
x = 10 # 
```

## 1.4 迭代器

【可迭代对象(iterable)衣特伯】是啥？

指的是可以依次返回其内部成员的对象，比如字符串、列表、字典、文件等等都是可迭代的对象

【迭代器（iterator）衣特瑞儿】是啥？

内置函数__iter(可迭代对象)得到迭代器，本质上迭代器也是可迭代对象

```python
# 可迭代对象，从语法上说就是那些具有__iter__的方法的对象
# 迭代器，从语法上说就是那些同事具有__next__和__iter__方法的对象。
- 迭代器调用__next__方法会调用迭代器中的下一个值；
- 迭代器调用__iter__方法返回迭代器本身；
```

优点：惰性取值；每次只取一个数据，不占内存

缺点：只能从前往后依次取值，不能返回头往前取值。就像象棋中的卒。只进不退

## 1.5 for 循环的本质

while循环可以做循环遍历操作，但是远不如for 循环简洁实用。

while循环适合做条件循环，for 循环适合做迭代器循环

【for循环的本质】：for循环底层利用了迭代器的原理

```python
# while + iterator
goods = ['mac','len','huawei','xiaomi']
goods_iterator = iter(goods)
while ture:
    tyr:
        print(next(goods_iterator)) # 无限循环依次取值
    except StopIteration: # 无限循环什么时候终止？捕捉异常终止循环
        break
        
for i in goods:
    print(i)
```

for 循环底层实现分三步

第一：调用iter()，将goods转化成迭代器goods_iterator

第二： 调用next() 方法到迭代器goods_iterator取值

第三：循环调用第二步，直到捕捉到异常后终止循环

【for循环的好处】：为序列和非序列类型提供了一种统一的迭代取值的方式

## 1.6 chain

python官方提供了itertools工具包，方便操作迭代器，这个包里提供了chian函数，兼顾内存效率和写法优雅

```python
from itertools import chian
a= [1,2,3,4,5]
b = [4,5,65,56]
c = {'a':1,'b':4}
for i in chain(a,b):
    print(i) # 1, 2 ,3 ,4,5,4,5,65,56
for i in chain(a,c.values()):
    print(i)   # 1,2,3,4,5,1,4
```

去除嵌套

```python
from itertools import chain
a = [[1,2,3],[4,5,6],[7,8,9]]
for i in chain(a):
    print(i) # 1,2,3,4,5,6,7,8,9
# 取值
b = list(chian(*a)) # [1,2,3,4,5,6,7,8,9]

```

### 练习：

```python
# 解嵌套、
a = [[1,2,3],[8,2,5],[1,5,9]]
test1 = [m for i in a for m in i] # [1, 2, 3, 3, 4, 5, 5, 6, 7]
test2 = list (itertools.chian(*a)) # [1, 2, 3, 3, 4, 5, 5, 6, 7]
test3 = sum(a,start=[]) # [1, 2, 3, 3, 4, 5, 5, 6, 7]
# 解嵌套、去重
test1 = list(setm for i in a for m in i()) # [1, 2, 3, 5, 8, 9]
test2 = list(set(itertools.chian(*a))) # [1, 2, 3, 5, 8, 9]
test3 = list(set(sum(a,start=[]))) # [1, 2, 3, 5, 8, 9]
# 解嵌套、去重、不破坏排序
# 方式一
new_list = []
test_set = set()
for i in a:
	m_list=[]
	for m in i:
		if m not in test_set:
			m_list.append(m)
			test_set.add(m)
	new_list.append(m_list)
# print(new_list)
test1 = [m for i in new_list for m in i]
print(test1) # [1, 2, 3, 8, 5, 9]
# 方式二：
test2 = list(dict.fromkeys(itertools.chain(*a)))
print(test2) # [1, 2, 3, 8, 5, 9]
```













# 2 数据结构

## 2.1基本数据结构

可变：列表、字典、集合

不可变：数字、字符串、元组（元组内无可变）

直接访问：数字

顺序访问（序列类型）：字符串、列表、元组

Key值访问（映射关系）：字典 

## 2.2 深浅拷贝

【什么是拷贝】：原封不动地复制一份新的，在不同的内存地址上，修改旧的不会影响新的。

变量赋值不是拷贝

变量赋值不是拷贝操作，因为变量名`list1`和变量名`list2`指向的是一块相同的内存地址

赋值操作后，无论是通过`list1`还是`list2`修改列表的元素，都会影响对方。

浅拷贝修改原始数据会影响对方

深拷贝不会，互相独立的

## 2.3 推导式

list_a = [m for i in iterable for m in i ]

## 2.4 namedtuple 有名元组

可以想象成一个元组但是他有名字，

兼顾元组的特性，一旦定义不能被修改

可以通过对象点的方式访问，。

## 2.5 OrderedDict 顺序字典

python3.6之前的字典是不按插入先后顺序排序的，但是可以实现这种功能，就是OrderedDict类型字典

python3.6之后的字典默认按照插入的先后顺序展示

## 2.6 defaultdict  不会错误的字典

普通的字典访问不存在的键时会抛出keyError异常

defaultdict类型字典在访问不存在的key时不会异常，会返回default

## 2.7 deque 双向队列

deque双向队列（double-end queue）类似于list的容器

deque 可以快速的在队列的头部和尾部添加、删除元素

list只能在尾部追加，不可以从头部加元素

```python
dq = deque()
dq.append(100)
dq.appendleft(300) # 从左边加元素
dq.pop()
dq.popleft() # 从左边弹出元素

```

## 2.8 二分查找

- 最简单的查找算法是遍历，但遍历的效率太低了。
- 二分查找（也叫折半查找）
- 二分查找的原理是，选择一个有序列表，确定最左边的值和最右边的值和最中间的位置值，比较待查元素和中间位置值，这样每次比较就可以排除一般的查找范围。
- 二分查找的前提是有序，特点是速度快，大数据查找的时候快一点

```python
# 实现方式： 
# 1、定义最左侧和最右侧的下标，
# 2、开始循环，
# 3、定义 中间值的下标
# 4、如果中间值大于查找值，那么就缩小范围，最右侧结束下标变成中间值-1 
# 5、反之，如果中间值小于查找值，那么就缩小范围，最左侧下标变成中间值+1
# 返回 -1 查找到了，就返回-1，如果没找到会一直找，
def query_target(list_test ,target):
    left = 0
    right = len(list_test)-1
    wile left<=right:
        mid = (left+right)//2
        if list_test[mid]==target:
            return mid
        elif list_test[mid]>target:
            right=mid-1
        else:
            left=mid+1
    return -1
```

优点：简单，高效快速

缺点：要求被查列表必须有序、递归占用空间、不适合动态数据

应用场景：有序列表、静态数据、快速查找

## 2.9 冒泡排序

实现的逻辑：从第一个元素开始，逐个比对每一个元素，如果自己比对比的元素大，那么自己的索引就前进一个

```python
def test_sort(test_list):
    n=len(test_list) # n是数组长度
    for i in range(n): # 遍历循环n遍
        for j in range(n-i-1): # 遍历内遍历，次数是n遍-当前次-1 自己是确定的，所以排除
            if test_list[j]>test_list[j+1]: # 如果自己比后面的大
                test[j],test[j+1]=test[j+1],test[j] # 那么自己跟后面的交换顺序
```

优点：简单易懂，稳定，**原地排序，不会生成新的列表**，不改变相等值的位置

缺点：性能差，不适合大规模数据排序

应用场景：小规模排序，

## 2.10 选择排序

实现逻辑：

1、找到数据中最小的元素，将这个元素与第一个元素交换位置

2、在剩下元素中找最小的元素，将这个元素与剩余元素中的第一个元素交换位置

3、循环

```python
def selection_sort(list1):
    n=len(list1)
    for i in range(n-1):
        min_index = i
        for j in range(i+1,n):
            if list[j]<list1[min_index]:
                min_index = j
        arr[i],arr[min_index]=arr[min_index],arr[i]
```



## 2.11 python内置排序算法

sort() 原地排序，不会生成新的数据，只对列表用

sorted() ，生成一份新数据，对所有可迭代对象都用



# 3 函数

## 3.1类型提示

```python
def get_name_with_age(name: str, age: int) -> str:
    pass
# 基本类型: int、float、bool、bytes
from typing import List: 
def process_items(items: List[str]):  # 复杂的类型提示
    for item in items:
        print(item)
```



## 3.2 函数是一等公民

函数可以作为入参、返回值、变量赋值、嵌套

## 3.3闭包函数

前面说了，函数是一等公民，所以函数可以作为入参和返回值传递

- 内嵌函数包含对外层函数作用域中变量的引用（非全局作用域的变量，是外层函数内部的变量），那么该内嵌函数就是闭包函数，称为闭包（Closures）
- 正常函数内部变量在函数调用之后就会被回收，但是闭包函数的出现，破坏了这个规则，让内部变量可以在函数外部使用

```python
def outer():
    x=1
    def inner():
        return x+1  # 此时引用了外层函数的内部变量，
    return inner # 且返回的是内嵌函数，

```

作用：

- 1、实现函数工厂：动态地生成和返回具有不同参数的函数
- 2、保护数据： 将变量封装在闭包中，限制对变量的直接访问，实现数据的封装和隐藏
- 3、装饰器：用于在函数前后执行额外的代码，如性能分析，日志收集等，用于加强函数

## 3.4 普通装饰器

目的：在不修改原有函数代码的情况下，增强函数，

```python
# 假设要在运行函数的时候，加上日志打印函数的方法：
def outfun(fun):
    def innerfun(*args,**kwargs):
        print(f"当前方法的名称是：{fun.__name__}")
        re = fun(*args,**kwargs)
        print(f"当前方法的名称是：{fun.__name__}")
        return re
    return innerfun

@outfun
def add(a,b):
    return a+b
result = add(1,2) # 运行的是上面定义的被装饰过后的内嵌函数innerfun
print(result)  
# 输出结果
# 当前方法的名称是：add
# 当前方法的名称是：add
# 3
# 加了装饰器语法@outfun之后，当我们运行add()方法的时候，实际上运行的是被装饰过后的函数innerfun
```



## 3.5 带参数装饰器

知道装饰器的原理之后，带参数的装饰器实现就很简单，就是在外层函数的外面，再嵌套一层函数，且最外层函数的入参就是带参装饰器的入参，接上面

```python
# 再到外层定义一个最外层函数
def overfun(login):
# 先定义一个装饰器函数
    def outfun(fun):
        def innerfun(*arg,**kwargs):
            if login== "debug":
                print(f"函数的名称是：{fun.__name__},等级是debug")
            result = fun(*arg.**kwargs)
            if login=="info":
                print(f"函数的名称是：{fun.__name__},等级是info")
            return result
        return innerfun
    return outfun

@overfun(login="info")
def testadd(a,b):
    return a+b
r = testadd(1,2)
print(r)
```

### 3.5.1 装饰器的优缺点和应用场景

- 优点： 不改变函数代码的前提下，对函数进行增强

- 缺点：无法一眼看清楚代码，有些人看不懂，嵌套比较多

- 应用场景：

  - 1、**日志记录，无需写login方法就可打印日志**
  - 2、**权限控制，判断入参有没有某个属性，如果没有就无权限**
  - 3、性能优化：
  - 4、数据验证：在输入输出的数据验证和转换方面，装饰器可以实现输入验证、类型转换
  - 5、代码计时：记录这段函数代码运行的花费的时间

  

## 3.6 可变长参数的高级用法

首先python是常规函数是严格按照定义的形参传的，如果实参数量大于形参就会报错

- 【可边长位置参数】*args 如过在最后一个形参前面加星号，那么在调用函数的时候，溢出的位置实参都会被接收下来，且会以元组的形式保存下来赋值给该形参。这里用 *args

```python
def fun(*args):
    print(*args)
foo(1, 2, 3, 4, 5, 6, 7)
# output:
1, 2, 3
(4, 5, 6, 7)
```

- 【可变长关键字参数】如果在最后一个形参前面加两个星号 那么在调用函数的时候，溢出的关键字仍然都会被接收，且会以字典的形式保存下来赋值给该形参，一般用  **kwargs传递

```python
def fun(x,**kwargs):
    print(x)
    print(kwargs)
foo(1, y=2, z=3)	# 溢出的关键字实参y=2，z=3都被**接收，以字典的形式保存下来，赋值给kwargs
#output:
1
{'z':3, 'y':2}
```

- 【补充一下 *args的用法】 将可迭代对象的元素打散传入函数

```python
def fun(x,y):
    print(x+y)
list1=[1,2]
fun(*list1) # 这里会将list1列表内的两个元素打散传进函数里面去
```

- 【补充一下 **的用法】 可以将字典每个key-value拆开为关键字传参

```python
def fun(x,y):
    print(x+y)
    
nums = {"a":1,"b":2}
fun(**nums)
```



## 3.7 yield

- 普通函数在被调用的时候，会从上往下依次执行函数代码。遇到return语句时立即退出函数且返回返回值，再次调用这个函数的试试，函数会再次从头到尾执行一遍
- 函数生成器被调用时，也是会从上往下执行代码，遇到yield语句后，再yield位置处挂起并且返回yield后的数据出来。此函数再次被调用的时候，会从挂起位置处（也就是yield处）再往下执行函数

- 【函数生成器】函数体包含yield关键字，就是函数生成器
- 生成器对象，指对象内置有____iter和 ____next方法，所以生成器本身就是一个迭代器，可以被for循环遍历

```python
def my_range(start,end,step=1):
    while start< end:
        yield start
        start+=step
g=my_range(1,5)
print(g) # 会显示g是一个迭代器对象<generator object my_range at 0x7f0ed8a31310>
print(next(g)) # 1
print(next(g)) # 2
print(next(g)) # 3
```

- 生成器函数的使用yiled语句实现的，python的yield表达式也很强大。yield不仅可以从函数体内往外取值，还可以从外部往函数体内传值，传值使用`generator.send(value)`

```python
def eater():
    print('Ready to eat')
    while True:
        food = yield
        print('get the food: %s, and start to eat' %food)


g = eater()
next(g)				# 传值前必须先调用一次生成器，让生成器先挂起来，等待接收yield赋值给food
g.send('包子')	   # 通过send方法将数据传给yield赋值给food,生成器内部有循环又会再次被挂起
g.send('牛奶')	   # send（）必须要有一个实参
g.send(None)		# 如果send的是None，则默认执行next(g)
```



## 3.8 匿名函数

- 匿名函数lambda 就是不命名的函数，一般用于一次性使用的场景，不属于任何类
- 定义有名字的函数用def 定义没名字的函数用lambda
- fun = lambda 入参 : 返回结果 lambda arguments: expression

```python
def fun(x,y):
    return x+y
fun2=lambda x,y:x+y # 冒号前面写入参，后面写返回结果
# 示例二
def sq(x):
    return x*x
map(sq,[y for y in range(10)]) # map组合，前面是方法，后面是传参
# 使用lambda
map(lambda x:x*x , [y for y in range(10)]) # 配合内置函数用，效果极佳，简洁有效
```



## 3.9 内置函数之filter (其实是一个类)

- filter是一个类，不是一个函数，查看源码发现
- fulter的入参是两个：function_or_None和iterable可迭代对象 
- 如果function是None的话，就报错

```python
def fun(x):
    return x%2==0
list1 = [1,2,3,4,5,6,7,8,9,10,12,142,352,4235,56,57,86,12,11]
a = filter(fun,list1)# 这里获得的是filter对象，要转化成对应的列表
print(list(a)) # [2, 4, 6, 8, 10, 12, 142, 352, 56, 86, 12]
# 用lambda 实现 定义匿名方法
a = filter(lambda x:x%2==0,list1)
print(list(a))  # [2, 4, 6, 8, 10, 12, 142, 352, 56, 86, 12]

```



## 3.10 内置函数值enumerate

- enumerate看源码，入参是一个可迭代对象，和一个默认为0的start起始值，
- 返回：以元组形式返回enumerate对象，元组内是（下标索引，值）的形式，
- 可以通过给start传参定义起始位置的索引值

```python
name=['asd','asda','qweq','fgdb']
for index value in enumerate(name,start=0): # 默认下标起始值是0
    print(index,value) # (0,'asd'),(1,'asda'),(2,'qweq'),(3,'fgdb'),
```



## 3.11 模块的本质

- 一个python文件就是一个模块，
- 模块是一堆功能的集合，算是一种代码“封装”的方式
- 内置模块，第三方模块，自定义模块。其实就是各种文件
- 模块的本质可以理解为是一个命名空间（Namespace）
- 命名空间相互隔离的，这个命名了的空间下面的东西，就只属于这个命名空间
- import 导入，就是导入了一个命名空间，就是导入了一个py文件

## 3.12 py文件的两种用途

- 1、当脚本被执行
- 2、当模块被导入使用
- 区别：
  - 脚本文件执行的时候，产品的命名空间会在程序解释后失效回收
  - 模块导入运行的试试，产生的命名空间会在引用计数为零的时候回收释放。
- 每一个py文件都有一个属性：____name____    这个不是他的命名空间 
- 当py文件被当做模块导入的时候，____name______ =="模块名"
- 所以if ______name_____=“____main___”时，就意味着该模块是主程序入口

## 3.13 包的本质

- 包： 就是一堆模块的集合，那单个模块是单个py文件，那包就是好多文件的集合，就是文件夹，且包含一个.______init______文件
- 导入包，起始就是导入包内init文件
- 不管是import包名.模块名 还是from 包名 import模块名，带点的时候，点的前面都是包名

# 4 面相对象

## 4.1 一切皆对象

- python中的所有的东西都是对象，类、函数方法、int 等等,普通的变量也是对象是实例化的对象
- type查看对象类型
- **通过dir函数查看对象下面有哪些属性和方法**
- 通过id()查看变量的内存地址

## 4.2 面向对象的封装思想

- 基本数据类型int/str/bool的功能单一，于是有了容器型数据类型list/tuple/dict/set等
- 独立的代码块使用起来冗余，于是又了函数，便于特定功能代码块的组织管理、重复使用
- 面向对象：将程序进一步整合，对象封装了数据属性和方法属性（数据和功能）即对象也是“容器”
- 进一步，许多同类型的对象，是不是也被抽象成了类，所以类也是“容器”，封装了同类型对象共有的数据和功能，可以重复使用





## 4.3 绑定方法和非绑定方法

- python中，类内部定义的函数分为两大类：绑定方法和非绑定方法
- 绑定方法有两个：绑定给对象的方法，绑定给类的方法；绑定给谁的方法，谁在调用的时候就不用传第一个参数，比如说self就是绑定给对象的方法，实例化对象调用的时候就不用传第一个参，cls就是绑定给类的方法，类使用的时候就不需要传第一个参
- 非绑定方法：类型普通函数，谁都可以使用，遵循普通函数的传参，目的只是为了封装在一起，如：静态方法。就是谁都可以调用且调用的时候不需要传第一个参

```python
class Student():
    def __init__(self,name,age):
        self.name=name
        self.age=age
    def edit_name(self,new_name):
        self.name = new_name
    @classmethod
    def get_student(cls,name,age):
        return cls(name,age)  # 相当于Student(name,age)
    @staticmethod
    def add(a,b):
        return a+b  # 这个方法没有用的类的任何属性方法，是一个静态方法，加装饰器
```



## 4.4 类装饰器property

- 用途一： 将函数属性伪装成数据属性
- 用途二：统一数据属性的查、改、删除操作

```python
# 用途一:
# 类中的某个数据值，其实是通过拿到类中的某个属性然后计算出来的值，
# 但是用户不想通过类的方法去拿到这个值，那就加上property装饰器 
# 然后就可以通过类似于对象.属性值的方式来通过对象.方法名这种方式拿到这个值

class People():
    def __init__(self,name,w,h):
        self.__name=name
        self.w=w
        self.h=h
    
    @property
    def bmi(self):
        return self.w / (self.h**2)
obj1 = People('jack'，66,1.75)
print(obj1.bmi)

```

```python
# 用途二：在修改和删除时做逻辑判断
# 当name 遇到查询时，出发被property装饰的函数的执行，
# 当name 遇到赋值操作，即 = 时触发被property.setter装饰的函数的执行
# 当name 遇到删除操作，即 del  时触发property.deleter装饰的函数的执行
class Poeple:
    def __init__(self, name, w, h):
        self.__name = name
        self.w = w
        self.h = h

    @property
    def name(self):
        return self.__name

    @name.setter # 修改属性的装饰器，当出发修改时，就会调用这个方法
    def name(self, value):
        if type(value) is not str:
            print('必须传入str类型')
            return
        self.__name = value

    @name.deleter # 删除属性的装饰器，当del删除某个属性的时候，触发这个方法
    def name(self): 
        print('不能删')


obj1 = Poeple('jack', 66, 1.75)
print(obj1.name)
obj1.name = 'aaa'
del obj1.name
```



## 4.5 cached_property

*`cached_property` 是一个 Python 装饰器，它可以用于定义一个缓存的属性，这意味着属性的值在第一次访问后会被计算，并将结果缓存起来，后续的访问会直接返回缓存的值，从而避免重复计算。*

*`cached_property` 装饰器可以在需要计算代价较高的属性时使用，以提高性能和效率。*

*在使用 `cached_property` 装饰器之前，你需要先安装一个名为 `cached-property` 的第三方库，它提供了这个装饰器的实现。*

*这个用的少*

## 4.6 属性查找顺序

属性或者方法的查找顺序的原则

- 先从对象自身身上找，有则使用；没有的话，再从类上找，有则使用；类上也没有的话就报错则报错AttributeError

## 4.7 隐藏属性

- 如果类的设计者不想某些属性被访问，就可以将该属性给隐藏起来。
- 隐藏属性可以隐藏类中的公有属性和对象的私有属性，对象访问会报错，
- 实现方法：使用双下划线开头命名的属性将会被隐藏
- 另：单下划线开头的属性和方法类似于保护属性，类内可以访问，类外也可以访问但不会提示

```python
class MyClass:
    def __init__(self):
        self.public_attr = 42
        self._protected_attr = 23
        self.__private_attr = "secret"

obj = MyClass()

print(obj.public_attr)  # 可以直接访问
print(obj._protected_attr)  # 可以直接访问，但是视为受保护
# print(obj.__private_attr)  # 不能直接访问，会报错

print(obj._MyClass__private_attr)  # 使用名称修饰的方式访问私有属性

```



## 4.8 开发接口

- 定义属性的目的是为了被使用，所以隐藏属性的目的不是单纯的隐藏，隐藏式为了更好的使用。
- 想要这些属性被使用，那就必须提供一个对外的接口，（没有被隐藏的属性）
- 隐藏数据属性：将数据隐藏起来就限制了类外部对类内数据的直接操作，然后类内应该提供相应的接口（函数方法）来允许外部间接的操作数据，接口之上呢可以附加额外的逻辑来对数据的操作进行严格的判断，比如说加上各种 if 啊，如果不符合就raise抛出异常

```python
class Student:

    def __init__(self, name):
        self.__name = name

    def get_name(self):
        print(self.__name)  # 通过该接口就可以间接地访问到名字属性
    
    @property
    def name(self):
        return self.__name

    def set_name(self, new_name):
        # 通过改接口判断用户修改的新名字是否合法；非法则修改，不合法就不修改
        if type(new_name) is not str:
            raise TypeError("名字必须是字符串类型")
        self.__name = new_name


stu = Student("jack")
stu.set_name("111")
stu.get_name()
print(stu.name)
```



## 4.9 python多继承

- 继承是面向对象思想的另一个特性。它的存在是为了解决类与类之间代码重复的问题。

```python

```



## 4.10 深度优先和广度优先

```python
# python2中区分经典类和新式类：
	- 经典类：没有继承object类的子类，以及该子类的子类子子类。。。
	- 新式类：继承了object类的子类，以及该子类的子类子子类。。。
    
# python3中全部默认继承object，所以都是新式类。
	- object类提供了一些常用内置方法的实现，如用来在打印对象时返回字符串的内置方法__str__
    - 通过类的内置属性__bases__可以查看类继承的所有父类
```



## 4.11 Mixin混合机制

- 允许将某个单一功能封装在独立的类中，然后通过一个类多重继承这些功能类，混合在一起，实现代码的复用和模块化
- 单一职责，一个类只关注单一功能
- 多重组合，通过多继承将多类混合在一起

```python
# Mixin 类
class LoggingMixin:
    def log(self, message):
        print(f"Log: {message}")

class EmailMixin:
    def send_email(self, subject, body):
        print(f"Sending email to {self.email}: {subject}, {body}")

# 具有 LoggingMixin 和 EmailMixin 功能的类
class User(LoggingMixin, EmailMixin):
    def __init__(self, username, email):
        self.username = username
        self.email = email

# 创建 User 对象并使用 Mixin 功能
user = User("alice", "alice@example.com")
user.log("User created")
user.send_email("Welcome", "Welcome to our website!")

```

- Mixin不是单一功能，只是一种编程思维，通常被定义为混合的类，类名在命名的时候都会在后面加一个Minxin来表示这个类是混合类

## 4.12 派生和组合

派生：在使用父类原有的方法的基础上，增加新的内容（用super( )方法重写父类方法）

```python
# 方式1：使用只用父类的方法，需要传self参数。
class People:
    def __init__(self, name, age, gender):
        self.name = name
        self.age = age
        self.gender = gender


class Student(People):
    def __init__(self, name, age, gender, code):
        People.__init__(self, name, age, gender)
        self.code = code


stu = Student("jack", 18, "男", 10111)
print(stu.__dict__)


# 方式2：使用super(), 按照MOR列表的顺序往下找
class Student(People):
    def __init__(self, name, age, gender, code):
        super().__init__(name, age, gender)  # 用super()重写了父类属性
        self.code = code
```

- 组合：对象的某个属性，是另一个类的实例化对象

```python
class Student:
    def __init__(name, age):
        self.name = name
        self.age = age

class Coursr:
    pass

stu = Student('jack', 18)
course_obj = Course()
stu.course = course_obj

# 继承是一种“是”的关系，比如老师是人、学生是人。
# 组合则是一种“有”的关系，比如老师有生日，老师有多门课程。
```



## 4.13 限制子类必须实现的方法

在父类中定义的方法，需要子类必须实现，此时就有两种限制方法

方式1：使用模块abc，（即抽象类abstract class的缩写）

就是加ab的装饰器的方法，然后你在继承的时候，必须去定义这个方法，不然实例化的时候就会出错

```python
import abc
import abc

# 指定metaclass属性将类设置为抽象类，抽象类本身只是用来约束子类的，抽象类本身不能被实例化
class Animal(metaclass=abc.ABCMeta):
    @abc.abstractmethod 		# 该装饰器限制子类必须定义有一个名为talk的方法
    def talk(self): 			# 抽象方法中无需实现具体的功能
        pass

class Cat(Animal):				# 但凡继承Animal的子类都必须遵循Animal规定的标准
    def talk(self):				# 必须定义talk方法						
        pass

cat=Cat() 				# 若子类中没有一个定义talk的方法则会抛出异常TypeError，无法实例化
```

方式2：使用 `NotImplementedError`

```python
class Animal:
    def talk(self):
        raise NotImplementedError("该方法必须被实现")
        
# 如果子类没有实现talk方法，子类调用talk时候使用父类的talk,此时直接抛出异常 NotImplementedError
```



## 4.14 isinstance

当我们需要获取一个对象的类型是，可以使用`type()

当我们需要判断一个对象是否是指定类型时可以使用`isinstance`函数快速判断。

```python
class People:
    def __init__(self, name):
        self.name = name


p = People("jack")
print(isinstance(p, People))			# 判断p 是否是People类型

a = 10
print(isinstance(a, int))
print(isinstance(a, (str, int)))		# 可以是多个备选类型，以元组的形式做第二个参数
```

### 4.15 反射机制

- 首先： 反射机制是什么？反射机制
  首先，python是一门动态语言，python的反射机制就是指，可以在程序运行的时候获取程序的属性方法，而不需要在编码时明确知道这些对象、方法名、或属性名的具体信息，反射使得你可以在程序运行时动态地获取、操作和探索对象的属性和方法。python的反射机制核心4点：

```python
hasattr(object, "x")  # 判断对象是否有这个属性，如果有 就返回布尔值True 或 False
getattr(object, name, default=None)  # 获取一个对象的name属性，如果name属性不存在的话，返回None
setattr(object, 'x属性名', 'y属性名')  # 更新对象x属性的值，就是object.x = 'y' 如果x属性不存在，那就新增一个y属性
delattr(object, 'y属性名')  # 删除对象的一个属性y，如果属性y不存在，就会报错


```

- 1、getattr( object, name,default=None):
- 2、hasattr():
- 3、setattr():
- 4、delattr():
- 5、dir(): 这个常用，这个就时获取对象所有属性
- 6、exec():和eval():函数

作用呢？

动态调用和访问对象的属性，getattr() setattr() hasattr()这些都可以随时修改和获取对象的属性

动态获取token

```python
class ApiClient:
  def __init__(self):
    self.token = None

  def login(self, username, password):
    # 假设这里调用登录接口，获取返回的 token，并将其存储到 self.token 中
    response = self.send_request('/login', {'username': username, 'password': password})
    self.token = response['token']

  def send_request(self, endpoint, data):
    # 发送接口请求的逻辑，返回响应数据
    pass

  def request_with_token(self, endpoint, data=None):
    if self.token:
      headers = {'Authorization': f'Bearer {self.token}'}
    else:
      headers = None
    return self.send_request(endpoint, data, headers)


# 在测试中使用反射获取 token 并进行接口请求
def test_api():
  client = ApiClient()
  client.login('your_username', 'your_password')

  # 使用反射获取 token
  token = getattr(client, 'token', None)
  assert token is not None, "Token not obtained"

  # 使用 token 发送其他接口请求
  response = client.request_with_token('/some_endpoint', {'param': 'value'})
  assert response['status'] == 'success', "Request failed"

  # ... 其他测试逻辑

```

```python
# 那接口自动化的过程中，还有什么其他的方式拿token吗
# 在接口自动化过程中，除了使用反射机制外，还有一些其他的方式可以获取 token，具体取决于接口的设计和实际情况。以下是一些常见的获取 token 的方式：

# 固定 Token： 在开发环境中，可以事先创建一个特定的用户账号，为其生成一个固定的 token，用于接口测试。这样每次测试可以直接使用这个固定的 token。

# 环境变量： 将 token 存储为环境变量，测试时从环境变量中读取 token 值。这样可以在不同环境中灵活切换和管理 token。

# 动态生成： 在每次测试运行前，通过自动化脚本执行登录操作，获取实时的 token。登录成功后，从接口响应中提取 token 并存储到变量中，供后续接口请求使用。

# Token 中心： 在一些复杂的系统中，可能会有专门的 token 中心用于管理用户的身份验证信息。测试时，可以调用 token 中心的接口获取有效的 token。

# JWT（JSON Web Token）： 如果接口使用了 JWT 进行身份验证，可以根据 JWT 的生成规则生成合法的 token。这需要了解 JWT 的具体生成方式。
```

### 4.16 单例模式

- 首先，单例模式是什么？ 是软件的一种设计模式，
- 目的：无论调用多少次产生的实例对象，都是指向同一个内存地址，仅仅只有一个实力（**一个对象**）
- 方式： 首先实现单例模式的手段有很多终端鹅，但总的原则是什么，是包装你定义的一个类，只要实例化一个对象，下一次再实例化对象的时候，就直接返回你已经实例化过的这个对象，不再做实例化的操作，
  **所以这里关键的一点就是，你该如何去判断这个类是否已经实例化过一个对象**
- 这里介绍两类方式：
  - 一个是通过**模块导入**的方式；
  - 二个事通过一个**魔法方法**去判断方式
- 应用的场景呢？什么时候用单例模式去创建一个类呢？
  - 网站计数器，确保全局只有一个计数器实例化对象，用来记录网站的总访问次数。
  - **配置管理器：配置信息的管理，确保你整套代码中，只有一个配置管理器的实例，用于统一管理配置信息，比如说同意发送请求，所有的请求都是通过这个实例化对象去访问的，
    **
  - **日志记录器：全局代码运行的时候确保只有一个日志记录器的实例化对象，用来记录这套代码运行时的日志记录**
  - **数据库连接池：保证整套代码运行的过程中，只有一个数据库连接池的实例，方便管理对数据库的同意连接和同意关闭连接池**
- 注意一下：单例模式虽然可以在很多特定场景下体统便利，但不可以过度依赖单例模式导致代码的可测试性和可维护性降低

通过**模块导入**的方式怎么实现：

```python
# singleton.py
class Singleton:
  def __init__(self):
    print("Singleton instance created")


singleton_instance = Singleton()
# 在singleton.py 文件里面定义了一个类Singleton，
# 通过singleton_instance = Singleton()
```

在另一个文件中导入这个模块

```python
# main.py
import singleton

# 创建第一个实例，会输出"Singleton instance created"
instance1 = singleton.singleton_instance

# 创建第二个实例，不会再次输出"Singleton instance created"
instance2 = singleton.singleton_instance

print(instance1 is instance2)  # 输出：True，说明两个实例是同一个实例

```

通过**类绑定方法**的方式来实现单例模式

```python
# 通过在类方法中控制实例的创建和返回，可以确保在程序中只有一个实例被创建。
class Singleton:
  _instance = None

  def __init__(self):
    if Singleton._instance is not None:
      raise ValueError(
        "Singleton instance already exists")  # 第二次实例化的时候，_instance不为空 抛出异常，不打印Singleton instance created 
    Singleton._instance = self
    print("Singleton instance created")

  @classmethod
  def get_instance(cls):
    if cls._instance is None:  # 第一次实例化的时候，类的_instance为空，走到了上面的方法了，打印Singleton instance created
      cls._instance = cls()  # 
    return cls._instance


# 创建第一个实例，会输出"Singleton instance created"
instance1 = Singleton.get_instance()

# 创建第二个实例，不会再次输出"Singleton instance created"
instance2 = Singleton.get_instance()

print(instance1 is instance2)  # 输出：True，说明两个实例是同一个实例
# 原理：类的绑定方法是第二种实例化对象的方式，
# 第一次实例化的对象保存成类的数据属性 _instance，
# 第二次再实例化时，在get_singleton中判断已经有了实例对象，直接返回类的数据属性 _instance
```

# 5 魔法方法

## init 和 del

- 为什么叫魔法方法？ 只有在某种条件下才触发，像魔法一样
- init ：当你定义的类，被实例化的时候，自动执行，给对象初始化属性，这个方法里面放self.xxx属性=xxx
  然后这个xxx由init方法入参，所以你在实例化对象的时候，就需要传这个参数进去，这个参数就是对象的属性
- 这个init默认是返回None的，默认不写
- 这里要说一下del析构方法，当对象被回收的时候出发执行(程序结束、对象引用技术为0称为垃圾时)
  这里要回想下python的垃圾回收机制的一种“引用计数”，就是当引用计数为0的时候，会被定义为垃圾，会被回收

## new方法

- new方法在init方法前执行，new函数会新建一个空对象，然后这个空对象会交给init函数初始化。这个方法结束的时候，把这个空对象return出去
- 这里说说实例化对象背后发生的三件事：
  - 1、new函数先会新建一个空对象，然后返回出去；给init函数
  - 2、该空对象执行init函数，就初始化了对象的属性；
  - 3、返回初始化完成后的对象，即实例化后的对象。
- new魔法方法的一些应用场景：
  - **实现单例模式**（Singleton）:使用new方法来确保只有一个实例，并在需要时返回同一个实例。这个可以在多线程环境下确保只有一个全局实例，
  - 定制不可变类型：如果你希望创建以恶搞不可变的自定义对象，可以通过在new方法中重写对象创建的逻辑来实现（不了解）
  - 继承不可变类型：当继承python内置的不可变类型（如元组、字符串）时，你可以通过重写new方法来创建定制过程（不了解）
  - 定制元类（Metaclass）：在元类中可以重写new方法，用于控制类的创建和实例化过程。（不了解，这个可以了解一下）
  - 对象池管理：在某些情况下，你可能需要使用对象池来重用已有的对象实例，可以通过new方法来实现对象池的管理。（不了解，这个可以了解一下）

```python
# 单例模式
class Singleton:
  _instance = None

  def __new__(cls):
    if cls._instance is None:
      cls._instance = super().__new__(cls)
    return cls._instance


# 创建 Singleton 类的实例
obj1 = Singleton()  # 1622254056400
obj2 = Singleton()  # 1622254056400

print(obj1 is obj2)  # 输出：True，因为 obj1 和 obj2 引用同一个实例

```

```python
# 了解new 方法
class Student:
  def __init__(self, name, age):
    print("init:", id(self))  # new: 2176264649120
    self.name = name
    self.age = age

  def __new__(cls, *args, **kwargs):
    obj = object.__new__(cls)  # init: 2176264649120
    print("new:", id(obj))
    return obj


stu1 = Student("jack", 19)
```

## 5.3 call

- 类中的call在对象被调用时出发。就是当对象加括号被调用时触发
- 对象或者变量，只有实现了call方法，才是可调用对象，才可以被执行，否则就会报错， object is not callable
- 定义了call后，你实例化的对象可以像函数一样被调用，

```python
class CallableClass:
    def __init__(self, value):
        self.value = value
    
    def __call__(self, x):
        return self.value * x

# 创建一个可调用的对象
callable_obj = CallableClass(5)

# 调用对象，就像调用函数一样
result = callable_obj(10)
print(result)  # 输出：50

```

总结就是，可以把类当方法直接调用

场景呢？

- 当你希望某个对象能像函数一样调用且获得返回值时
- __call__方法并结合with语句和`__enter__`和`__exit__`方法。实现上下文管理
- call实现装饰器

```python
class MyDecorator:
    def __init__(self, func):
        self.func = func # 函数作为入参，传进来作为属性

    def __call__(self, *args, **kwargs):
        print("Before function is called") # 调用属性
        result = self.func(*args, **kwargs) # 这是被装饰的方法
        print("After function is called")
        return result

@MyDecorator
def my_function(x, y):
    return x + y

result = my_function(3, 5)
print("Result:", result)
Before function is called
After function is called
Result: 8

```

- **装饰器实现，两种方式**
  - **第一个是常规的，闭包，嵌套函数**
  - **第二个就是定义带call的类。讲函数作为init入参传进来**

## 5.4 str和repr

- str：当对象被访问打印时触发执行，他必须有一个字符串类型的返回值

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return f"Person(name={self.name}, age={self.age})"

person = Person("Alice", 30)
print(person)  # Output: Person(name=Alice, age=30)

sut = Student("name","age")
print(sut) # 这个时候打印出来的内容，就是str方法return出来的内容
```

好这个我知道了，那应用的场景呢？

- 总之，`__str__` 魔法方法适用于需要自定义对象的可读性、用户友好性和调试信息的情况。它使你能够以更有意义的方式呈现对象，并提供有关对象状态和属性的重要信息。

- repr，本质和srt一样，都是对象被打印时显示的内容，但是
- **与`__str__`的区别：** `__str__` 应该返回更友好、易读的字符串，而 `__repr__` 则应该返回更详细、可复制的字符串，通常包含足够的信息来重新创建对象。

## 5.5 比较系列

两个对象是可以比较的，但是比较的结果可能不是我们预期的，此时可以重写比较系列的魔法方法，实现自定义比较逻辑

- eq
  - `__eq__` 方法是 Python 中的一个魔法方法，用于定义对象的相等性比较操作。当你在自定义类中实现了 `__eq__`
    方法时，你可以自定义对象之间的相等性判断规则

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __eq__(self, other):
        if isinstance(other, Person):
            print("eq被执行了")  # 只有当你在判断两个对象是否相等时，这个方法才会被触发
            return self.name == other.name and self.age == other.age
        return False


person1 = Person("Alice", 25)
person2 = Person("Bob", 30)
person3 = Person("Alice", 25)
# print(person1.name)
print(person1 == person2)  # False，根据 __eq__ 方法的定义，person1 和 person2 不相等
print(person1 == person3)  # True，根据 __eq__ 方法的定义，person1 和 person3 相等
# eq被执行了
# False
# eq被执行了
# True
```

- 同样的道理，其他比较系列的放啊
- nq，实现的是是够不相等的逻辑。如果没有实现，则默认是eq的结果取反。
- 该系列其他魔法方法：`__lt__、__gt__、__le__、__ge__`分别表示小于、大于、小于等于和大于等于。

## 5.6 attr系列 阿特

- 这个系列就和之前学习反射的时候是一样的道理

```python
class Person:

    def __init__(self, name):
        self.name = name

    def __getattr__(self, item):
        print('调用不存在的属性会触发我')
        return self.__dict__.get(item) # 
        # return self.item      # 不能使用，会造成递归。

    def __setattr__(self, key, value): 
        print('设置修改对象属性时触发我') # 这个在实例化对象的时候会被触发，可以有其他用处
        self.__dict__[key] = value

    def __delattr__(self, item):
        print('删除对象属性时触发我')
        self.__dict__.pop(item)


p = Person('jack')      # 触发__setattr__
p.name = 'mack'         # 触发__setattr__
print(p.age)            # 触发__getattr__
p.age = 18              # 触发__setattr__
print(p.age)            
del p.age               # __delattr__
```

- 示例二，让字典，实现像对象一样的点操作

```python
class MyDict(dict):
    abc = "abc"

    def __getattr__(self, item):
        print("字典对象通过点访问不存在的属性时触发")
        return self.get(item)

    def __setattr__(self, key, value):
        if not isinstance(value, str):
            raise ValueError('值必须是字符串类型')
        self[key] = value


d = MyDict({'name': 'jack'})
print(d.name)               # 触发 __getattr__
print(d.abc)                # 没有触发 __getattr__
```

## 5.7 item系列 伊藤姆，和attr一样用

实现普通对象像字典一样通过 [ ] 操作 和attr一样理解

item:项目

attr: attribute： 属性的英文

```python
class Person(object):

    def __init__(self, name):
        self.name = name

    def __setitem__(self, key, value):
        print("[]设置值时触发")
        setattr(self, key, value)

    def __getitem__(self, item):
        print("[]取值时触发")
        return getattr(self, item)

    def __delitem__(self, key):
        print("del p[key]时触发", key)


p = Person('jack')
p['name'] = 'mack'			 # 需要__setitem__才可以
print(p['name'])           	  # 需要__getitem__才可以
print(p.__dict__)

del p["name"]				# 需要__delitem__才可以
```

## 5.8 enter恩特和exit艾涩特

- 上下文管理器：
  - 执行代码块前后的操作，
  - 文件也是代码块
- with ：顺着
  - 顺着上下文管理器
- with open(file , mode操作模式)  mode就是r读取和w写入的模式选择
  - 这里的with open中的open( )函数所返回出来的对象就是一个上下文管理器，这个对象实现了enter方法和exit方法 用于对文件的自动打开和关闭，
  - 如果没有open，那我们的代码应该是怎么写的？
    - 就像数据库一样
    - file = open ( 'file' , mode )
    - file.write("hello,world")
    - file.close( )
    - 但是这样写不好看很麻烦，with open 就自动帮我们实现了打开和写入和关闭的操作
- 好，说到这里，就能理解enter和exit了
- 这个代码里的MyOpen就是我们的自己定义的上下文管理器，这个类所返回出来的对象就是一个上下文管理器，实现了enter和exit方法打开和关闭

```python
class MyOpen:
    def __init__(self, file_name: str, mode="r"):
        self.file = open(file_name, mode)

    def __enter__(self):
        print("进入with语句块时触发")
        return self.file        # 返回值赋值给 as后面的接收值

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("退出with语句块时触发，不论with语句块内是够有异常报错，__exit__都会被执行")
        self.file.close()


        
with MyOpen("text.txt", "w") as f:
    f.write("hello world")
```

## 5.9 iter和next

见名知意，这两个方法是实现迭代器功能的，比如实现一个range

这样我们就知道了range原理

```python
# 普通range
for i in range(10):
    print(i)
```

- 通过自己定义这两个魔法方法实现自己的range

```python
import time

class MyRange():
    def __init__(self,total: int,step: int=1):
        self.count = 0  # 这里都是定义属性
        self.total = total
        self.step = step 
    def __iter__(self):  # 
        print("1111")
        return self  # for循环第一个进入时执行一次，需要返回一个实现了__next__的迭代器对象
    def __next__(self):
        time.sleep(0.5)
        self.count += self.step # 没次运行加1或者自定义的数
        if self.count == self.total:
            reise StopIteration # 如果count计数等于total总数时引发迭代异常，不是抛出，这个迭代异常表示迭代结束
        return self.count 
    
for i in MyRange(10,2):
    print(i)
```

- 总结一下，
- iter 当一个类，定义了iter魔法方法，这个类的实例，就被认为是可迭代的（iterable)
  - iter方法应返回一个迭代器对象，可以是self，也可以是另一个实现了next方法的对象
- next 方法：这个方法用于获取迭代中的下一个值。
  - 如果没有更多的值可迭代，应该要引发StopIteration异常，表示迭代结束

## 5.10其他魔法方法

### getattribute系列 attribute艾tiubiute就是属性的意思

- 调用对象不存在的属性的时候，会访问getattr
- 访问对象的属性不管存在不存在都会触发getattribute方法
- 除非getattribute抛出AttributeError异常才会触发getattr
- 所以当你访问对象的属性不管存在不存在都会触发getattribute异常

```python
class Foo:
    def __init__(self,x):
        self.x = x

    def __getattr__(self, item):
        print('执行的是我')

    def __getattribute__(self, item):
        print('不管是否存在,我都会执行')
        raise AttributeError('哈哈')


f1=Foo(10)

f1.x
f1.y
```

### module、class、name

- **module**：模块，表示当前错爱早的对象在哪个模块
- class：类 表示当前操作对象的类是什么
- name： 表示当前对象的名字是什么
-

### slot、all

- slot：控制对象在实例化后可以持支持哪些属性
- 是一个用于限制对象属性的特殊属性，它是一种用于优化内存占用和属性访问速度的机制。通过在类中定义 `__slots__`
  属性，你可以指定一个属性名称的列表，从而限制类的实例只能具有指定列表中的属性。
- all：
- 在模块文件中设置 `__all__` 变量，当其它文件以“from 模块名 import *”的形式导入该模块时，该文件中只能使用 `__all__`
  列表中指定的成员。

```python
# tools.py

def add(a: int, b: int):
    return a + b

def mul(a: int, b: int):
    return a * b


def xsum(nums: list):
    return sum(nums)


__all__ = ["add", "mul"]
```







# 元类

## 6.1 类也是对象

- 元类是什么？要先了解类是什么？
- Python是一切皆对象，哪怕你定义一个变量，它也是对象，那类是什么？ 类可以想象成是对象的模版，是类定义了对象，对象是类实例化的产物，
- 那类是对象的模板，什么是类的类（模版）呢？
- 元类就是类的类（模版）默认元类type
- 你可以自定义这个元类来实现有区别于类的类

## 6.2 class机制

class是python的一个关键字，目的是用来创建类，那这个关键字的背后是什么逻辑呢？

- 第一步：**获取类名** class_name = Student
- 第二步： **获取基类们：** class_bases=(object,)
- 第三步：**获取类的名称空间：** class_dict = {"--init--" ：--init--,"--talk--":talk}
- 第四步：**调用元类type实例化产生Student类这个对象**

```python
def __init__(self, name, age):
    self.name = name
    self.age = age


def talk(self):
    print('hello')


class_name = "Student"
class_bases = (object, )
class_dict = {"__init__": __init__, "talk": talk}  #  字典


Student = type(class_name, class_bases, class_dict)  # 自定义了元类信息，Student是实例化对象

stu = Student("jack", 18)
print(stu.talk())
```

- 但是如果按照这四步走就比较繁琐，所以正常是用python的关键字class 来定义类的

## 6.3 自定义元类

上面我们知道了class的原理，那我们自定义元类，就是在做第四步的自定义，即使用不同的元类实例化这个对象，目的是为了按照需求控制类的定义和调用

metaclass=type就是让他指向type元类，这是所有类的基石

```python
class Student(metaclass=type):	# class机制默认的元类是type：我们可以修改metaclass参数来选择自定义元类
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def talk(self):
        print('hello')
```

- type是一切类的即是，所以我们自定义的元类，也必须继承自type
- 自定义的元类继承type的目的是使用type的大部分功能，我们只定制（重写方法）我们需要的那一部分功能

```python
class Mymeta(type):		# 只有继承了type的类才能作为元类使用
    # 在这个里面去重写type的方法去自定义自己的元类
    pass


class Student(metaclass=Mymeta):	# 使用Mytema元类，即Mymeta(class_name, class_bases, class_dict)
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
    def talk(self):
        print('hello')
```

## 6.4 自定义元类控制类的定义

自定义元类定制类的时候，需要再自定义的元类中实现init()方法

```python
class Mymeta(type):
    def __init__(self, class_name, class_bases, class_dict):

        if not class_name.istitle():			# 自定制需求 istitle()用于检查字符串的首字母是否大写，如果大写就是Ture，否则Flase
            raise NameError('类名首字母必须大写')
 
        if not self.__doc__:  # # 如果类的__doc__属性是空，就抛出异常 doc就是注释那里
            raise TypeError('类必须要有文档注释')

        super().__init__(class_name, class_bases, class_dict)


# People = Mymeta(class_name, class_bases, class_dict),
class People(object, metaclass=Mymeta):
    """
    deox
    """
    x = 10
    def f(self):
        pass



print(People.__dict__)
```

## 6.5实例化对象的本质是什么？

回顾一下，实例化一个对象时会发生什么？ 

- **第一件事：创建了一个空对象，--new--方法**
- **第二件事：初始化了这个空对象  --init--**
- **最后：返回初始化完成的对象**
  - new（）创建空对象，且返回这个空对象
  - init() 接收了这个空对象，并完成了初始化该对象
  - 最后，返回初始化完成的对象。

整个三步流程，是由类的类，即元类中的--call--()方法管理的（定义.类() ），因为实例化对象，类加括号，即类的调用。类被当一个对象看待时，直接以类方法调用，就会触发它的--call--()函数的执行，即实例化对象时，出发了元类的--call--()函数

在元类--call--()内实现实例化的三件事。

当我们默认使用的是type元类时，想要**定制实例化的这个过程中**的需求是无法实现的，因为我们无法修改内置元类type的--call--方法。

当我们使用自定义元类的时候，就可以实现**实例化过程需求的自定义**，因为我们可以重写自定义元类的--call--方法，从而实现自定义实例化需求

## 6.6 自定义元类控制类的调用

类的调用： 就是类加括号，也就是实例化对象

**你实例化一个类的对象时，实际上会调用类的 `__call__` 方法（如果定义了的话）。这种行为使得类的实例可以像函数一样被调用。**

控制类的调用就是控制对象的额实例化过程。类的调用就会触发元类的--call--方法执行

```python
class Mymeta(type):
    def __call__(cls, *args, **kwargs):
        # 第一步: 调用Student下面的__new__创建一个空对象, 无则使用类(type)的__new__
        obj = cls.__new__(cls, *args, **kwargs)
        # 第二步：调用Student下面的__init__初始化对象
        cls.__init__(obj, *args, **kwargs)        # 等价于： obj.__init__(*args, **kwargs)
        # 第三步：返回对象
        return obj


class Student(object, metaclass=Mymeta):
    def __init__(self, name, age):
        self.name = name
        self.age = age


jack = Student('jack', 18)   # People.__call__('jack', 18)
```

## 6.7 通过new实现单例模式

回顾一下单例模式：

- 一个类只实例化一个对象的一种编程思维，就是单例模式
- 怎么实现： 通过自定义--new--()魔法方法实现，判断类的实例化对象是否已经有了，有了就直接返回这个实例化对象，没有就可以new一个实例化并保存返回。看看对象

```python
class Student():
    _instance = None # 默认类的属性_instance是空
    def __new__(cls,*args, **kwargs):
        self.name = name
        self.age = age
        
    def __new__(cls,*args, **kwargs):  
        if cls._instance:  # 判断，如果cls._instance is Ture就是指判断他是否有实例
            return cls._instance # 如果有就直接返回这个实例
        else:
            cls._instance = super().__new__(cls)    # 如果没有，就新建一个实例化对象
            return cls._instance   # 并且返回
        
    def __new__(cls, *agrs, **kwagrs):
        if not cls._instance:
            cls._instances = super().__new__(cls)  # 如果没有，就新建一个
        return cls.instances  # 不管有没有实例化对象，都返回这个对象， 如果有就直接返回

```

## 6.8 通过元类来实现单例模式【重点】

思路是什么？

- 首先，这个实现的点在哪里？在类的定义阶段就确保类的实例化行为符合单例模式，
- 呐你单例模式，是在定义类的时候做判断，通过类的--new--()方法里面去做判断，如果这个类有实例化对象，就返回这个对象，如果没有就新建一个对象返回，
  - 这里插一句，实例化的过程发生了什么？1、--new--新建一个空对象且返回出去给--init-- 2、--init--接收这个空对象，进行初始化，就是slef.name=name，3、将这个初始化过的对象返回去。就是调用类的‘爸爸’’元类的--call--方法，--call--就是.类()把类当方法用的方法
- 好的，现在我们知道了实例化过程，那我们除了可以在new方法这里做判断，还可以在定义类的‘‘爸爸’’元类的时候去做判断
- 因为你在实例化的时候，就是调用了类的‘‘爸爸’’元类的--call--方法去实例化的（--call--把类当方法用）
- 好，现在我们知道了要去自定义元类的--call--方法，也就是在调用--call--的时候去做判断，判断这个类有没有实例化对象，如果有就直接返回这个对象，如果没有就新建一个对象然后再返回这个对象。
- 好我现在要再自定义的原来上面去做判断是吧，那怎么自定义元类？且看代码

```python
class Mymeta(type):
    def __init__(cls, name,bases,dic):
        super().__init__(name,bases,dic)
        cls._instance = None   # 将记录类的实例化对象的数据属性放在元类中自动定义了 这里和之前定义类的时候是一个意思
    def __call__(cls,*args, **kwargs):  # 此call会在类被调用（即实例化时出发）
        if cls._instance:  # 判断类有没有实例化对象
            return cls._instance # 如果有就返回这个实例化对象啊
        else:  # 如果没有
            obj = cls.__new__(cls, *args, **kwargs) # 那就控制类造一个空对象并完成初始化
            obj.__init__(*args,**kwargs) #  那就控制类造一个空对象并完成初始化
            cls._instance = obj # 保存这个对象，那cls的_instance是这个对象，下一次再实例化的时候就直接返回而不用再造对象
            return obj # 返回这个对象
        
        
class Student(metaclass=Mymeta):
    def __init__(self,name,age):
        self.name=name
        self.age=age
        
        
stu1 = Student("jone",18)
stu2 = Student('xiaoming',19)
print(stu1 is stu2)
print(stu1.__dict__,stu2.__dict__)
```

原理解读：类定义时会调用元类下面的--init--(),类调用（实例化对象）时会触发元类下的--call--方法

类在定义时，给类新增一个空的数据属性，

第一次实例化的时候，实例化之后就会将这个对象赋值给类的数据属性； # 所以第一次实例化的时候，就获得了这个属性

第二次再实例化的时候，直接返回类的这个数据属性

和自定类的时候单例不同的是，类的这1个数据属性是放在元类中自动定义的，而不是在类中显示的定义的

类调用时，出发元类--call--方法判断是否有实例化对象，而不是在类的绑定方法中做判断。

最后我说一句，其实两个的原理是一样的，

- 你使用定义类的方式：你在类中做了判断，其实就是你是在实例化对象的‘‘爸爸’’定义类中的--new--也就是新建对象的时候做的判断，
- 你使用自定义元类的方式，也就是你在定义类的‘‘爸爸’’元类的--call--方法做的判断，因为类实例化对象就是调用的元类的--call--方法
- **那二者的区别？**
  - 你全局只有一个类的单例，那你就在定义类的时候做下判断就好，那如果你的程序要定义好几个只能单例的类的？不可能每个类你都去重写--new--方法吧？ 这个时候你就可以重写（自定义）元类去实现呀，。这样你每个定义类只需要继承自定义元类就行。

拓展一下，场景：

1. **验证和数据处理：** 你可以通过自定义元类来验证类的属性和方法是否符合某些规则。例如，你可以创建一个元类，确保所有的属性都是特定类型，或者属性的值满足某些条件。
2. **日志和调试： 自定义元类可以用来自动添加日志、跟踪或调试信息到类的方法中，从而帮助你更好地理解代码的执行过程。**
3. **ORM（对象关系映射）：** 自定义元类可以用于创建 ORM 框架中的数据库模型，将 Python 类映射到数据库表，从而实现数据的存储和检索。
4. **API 定义：** 通过自定义元类，你可以创建领域特定语言（DSL）的类，从而提供更高级别的 API 接口，以适应特定的业务需求。
5. **依赖注入：** 自定义元类可以用于自动注入依赖项，从而简化类的构造过程。
6. **单元测试辅助：** 自定义元类可以用于在测试中自动生成 Mock 对象，帮助进行单元测试。
7. **实现属性访问控制：** 通过自定义元类，你可以控制类的属性访问权限，从而实现公开、私有和受保护的属性。
8. **插件系统：** 自定义元类可以用于创建可插拔的插件系统，允许你动态地扩展类的功能。

**日志和调试：**

```python
class DebugMeta(type):
    def __new__(cls, name, bases, cls_dict):
        for attr_name, attr_value in cls_dict.items():
            if callable(attr_value):  # 检查属性是否是可调用的（方法）
                cls_dict[attr_name] = cls.debug_decorator(attr_value)  # 使用装饰器替换方法
        return super().__new__(cls, name, bases, cls_dict)

    @staticmethod
    def debug_decorator(func):
        def wrapper(*args, **kwargs):
            print(f"Calling {func.__name__} with args: {args}, kwargs: {kwargs}")
            result = func(*args, **kwargs)
            print(f"{func.__name__} returned: {result}")
            return result
        return wrapper

class DebugClass(metaclass=DebugMeta):
    def add(self, a, b):
        return a + b

    def subtract(self, a, b):
        return a - b

# 使用
debug_instance = DebugClass()
result = debug_instance.add(5, 3)
print(result)

```

- 自定义元类的new方法，
  - 自定义一个装饰器，就是被装饰的方法运行前打印方法名称和入参之类的，方法结束的时候打印一下return值
  - 在new方法里写，遍历后判断类的属性是否可调用 if callable(属性名):如果可以调用就使用装饰器装饰一下这个方法 打印日志
  - 然后再定义类的时候继承这个自定义元类。

**验证和数据处理**

- 就是自定义元类new方法，在里面做判断，如果类你定义的类的属性符合某个要求，就没事，如果不如何对应的要求，就会抛出异常报错
- 然后你在定义类的时候，指定元类
